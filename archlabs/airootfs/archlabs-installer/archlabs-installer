#!/usr/bin/env bash
# vim:ft=sh:fdm=marker:fmr={,}

# ArchLabs Base Installer (version 1.2 - Feb, 2018)
# Modified and adapted by Nathaniel Maia for use in Archlabs
# Originally Written by Carl Duff for PacBang Linux
# This program is free software, provided under the GNU GPL

# Installation
ISO_USER="liveuser"               # Live user account
DIST="ArchLabs"                   # Distributor name for grub etc
VERSION="ArchLabs Installer 1.3"  # Installer Name / Version
ANS="/tmp/.archlabs-installer"    # Temp file to store answers
MNT="/mnt"                        # Installation mountpoint
ERR="/tmp/.errlog"                # error log file
IMG="/run/archiso/sfs/airootfs/"  # Squash image to install
BYPASS="$MNT/bypass/"             # Squash image mountpoint
MOUNT_OPTS="/tmp/.mnt_opts"       # file system mount options
CMAP="us"                         # Default virtual console keymap
XMAP="us"                         # Default X11 keyboard layout
LOC="en_US.UTF-8"                 # Default system locale
ARCHI=$(uname -m)                 # Display whether 32 or 64 bit system
SYSTEM="Unknown"                  # Default for BIOS or UEFI.
EFI_MNT="/boot/efi"               # EFI partition mountpoint
MH=0                      # Highlight items for Main Menu
HIGHLIGHT=0                       # Highlight items for submenus
SUB_MENU=""                       # Submenu to be highlighted
FS_OPTS=""                        # FS mount options available
CHK_NUM=16                        # Default mount options checklist length
LVM=0                             # Logical Volume Management Detected?
LVM_SEP_BOOT=0                    # 1 = Seperate /boot, 2 = seperate /boot & LVM
LV_VG=""                          # Name of volume group to create or use
LV_VG_MB=0                        # MB remaining of VG
LV_NAME=""                        # Name of LV to create or use
LV_SIZE_INVALID=0                 # Is LVM LV size entered valid?
VG_SIZE_TYPE=""                   # Is VG in Gigabytes or Megabytes?
LUKS=0                            # Luks Detected?
LUKS_DEV=""                       # If encrypted, partition
LUKS_NAME=""                      # Name given to encrypted partition
LUKS_UUID=""                      # UUID used for comparison purposes

select_language() {
    dialog --backtitle "$BT" --title " Select Language " --menu \
        "Language / sprache / taal / språk / lingua / idioma / nyelv / língua" 0 0 9 \
        "1" $"English            (en_**)" "2" $"Español            (es_ES)" \
        "3" $"Português [Brasil] (pt_BR)" "4" $"Português          (pt_PT)" \
        "5" $"Français           (fr_FR)" "6" $"Russkiy            (ru_RU)" \
        "7" $"Italiano           (it_IT)" "8" $"Nederlands         (nl_NL)" \
        "9" $"Magyar             (hu_HU)" 2>$ANS

    case "$(cat $ANS)" in
        "1") source /archlabs-installer/english.trans    ; LOC="en_US.UTF-8" ;;
        "2") source /archlabs-installer/spanish.trans    ; LOC="es_ES.UTF-8" ;;
        "3") source /archlabs-installer/p_brasil.trans   ; LOC="pt_BR.UTF-8" ;;
        "4") source /archlabs-installer/portuguese.trans ; LOC="pt_PT.UTF-8" ;;
        "5") source /archlabs-installer/french.trans     ; LOC="fr_FR.UTF-8" ;;
        "6") source /archlabs-installer/russian.trans    ; LOC="ru_RU.UTF-8" ;;
        "7") source /archlabs-installer/italian.trans    ; LOC="it_IT.UTF-8" ;;
        "8") source /archlabs-installer/dutch.trans      ; LOC="nl_NL.UTF-8" ;;
        "9") source /archlabs-installer/hungarian.trans  ; LOC="hu_HU.UTF-8" ;;
        *) exit 0
    esac

    # Always enable en_US
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen

    if [[ $LOC != "en_US.UTF-8" ]]; then
        sed -i "s/#${LOC}/${LOC}/" /etc/locale.gen
    fi

    locale-gen >/dev/null 2>&1
    export LANG="$LOC"
}

######################################################################
##                  Utility and Check Functions                     ##
######################################################################

check_requirements() {
    if [[ $(whoami) != "root" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --infobox "$_RtFailBody" 0 0
        sleep 3 && exit 1
    fi
    if [[ ! $(ping -c 1 google.com) ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --infobox "$_ConFailBody" 0 0
        sleep 3 && exit 1
    fi
    echo "" >"$ERR"
}

id_system() {
    if grep -q 'Apple' /sys/class/dmi/id/sys_vendor; then
        modprobe -r -q efivars || true
    else
        modprobe -q efivarfs
    fi

    if [[ -d "/sys/firmware/efi/" ]]; then
        if grep -q /sys/firmware/efi/efivars <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        SYSTEM="UEFI"
    else
        SYSTEM="BIOS"
    fi

    BT="$VERSION - $SYSTEM ($ARCHI)"
}

arch_chroot() {
    arch-chroot $MNT /bin/bash -c "$1"
}

check_for_error() {
    if [[ $? -eq 1 ]] && grep -wqi "error" "$ERR"; then
        msg=$(cat "$ERR")
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$msg" 0 0
        rm -rf ${MNT:?}/* ; main_menu
    fi
}

check_mount() {
    if ! grep -q "$MNT" <<< "$(lsblk -o MOUNTPOINT)"; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
        main_menu
    fi
}

check_base() {
    if ! [[ -e $MNT/etc ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        main_menu
    fi
}

show_devices() {
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT \
        | grep "disk\|part\|lvm\|crypt\|NAME\|TYPE\|SIZE" >/tmp/.devlist
    dialog --backtitle "$BT" --title " $_DevShowOpt " --textbox /tmp/.devlist 0 0
}

######################################################################
##                  System Settings Functions                       ##
######################################################################

set_keymap() {
    CMAPS=""
    local maps
    maps=$(ls -R /usr/share/kbd/keymaps)
    maps=$(sed 's/\.map\.gz//g' <<< "$(grep "map.gz" <<< "$maps")")

    for i in $(sort <<< "$maps"); do
        CMAPS="$CMAPS $i -"
    done

    dialog --backtitle "$BT" --title " $_VCKeymapTitle " \
        --menu "$_VCKeymapBody" 20 40 16 $CMAPS 2>$ANS || prep_menu
    CMAP=$(cat $ANS)

    echo -e "KEYMAP=$CMAP\nFONT=$FONT" > /tmp/vconsole.conf
}

set_xkbmap() {
    XMAPS=""
    local maps
    maps=(
    af al am at az ba bd be bg br bt bw by ca cd ch cm cn
    cz de dk ee es et eu 'fi' fo fr gb ge gh gn gr hr hu
    ie il in iq ir is it jp ke kg kh kr kz la lk lt lv ma
    md me mk ml mm mn mt mv ng nl no np pc ph pk pl pt ro
    rs ru se si sk sn sy tg th tj tm tr tw tz ua us uz vn za
    )

    for i in "${maps[@]}"; do
        XMAPS="$XMAPS $i -"
    done

    dialog --backtitle "$BT" --title " $_PrepKBLayout " \
        --menu "$_XkbmapBody" 0 0 16 $XMAPS 2>$ANS || prep_menu
    XMAP=$(sed 's/_.*//' "$ANS")

    KFILE='Section "InputClass"\n\tIdentifier "system-keyboard"\n\tMatchIsKeyboard "on"'
    KFILE="$KFILE\n\tOption \"XkbLayout\" \"$XMAP\"\nEndSection"
    echo -e "$KFILE" > /tmp/01-keyboard.conf

    setxkbmap "$XMAP" 2>>"$ERR"
    check_for_error

    DKFILE='# KEYBOARD CONFIGURATION FILE\n\nConsult the keyboard(5) manual page.'
    DKFILE="$DKFILE\n\nXKBMODEL=\"\"\nXKBLAYOUT=\"$XMAP\"\nXKBVARIANT=\"\""
    DKFILE="$DKFILE\nXKBOPTIONS=\"\"\nBACKSPACE=\"guess\""
    echo -e "$DKFILE" > /tmp/keyboard
}

set_locale() {
    LOCS=""
    LOCL=$(sed 's/ UTF-8//g' <<< "$(sed 's/#//g' <<< "$(grep -v "# " /etc/locale.gen)")")

    for i in $(grep .UTF-8 <<< "$LOCL"); do
        LOCS="$LOCS $i -"
    done

    dialog --backtitle "$BT" --title " $_ConfBseSysLoc " \
        --menu "$_localeBody" 0 0 12 $LOCS 2>$ANS || config_base_menu
    LOC=$(cat $ANS)

    sed -i "s/en_US.UTF-8/${LOC}/g" $MNT/etc/locale.conf
    cp -f $MNT/etc/locale.conf $MNT/etc/default/locale
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/g" $MNT/etc/locale.gen
    sed -i "s/#${LOC}/${LOC}/g" $MNT/etc/locale.gen
    sed -i "s/en_US.UTF-8/${LOC}/g" $MNT/etc/default/locale
    arch_chroot "locale-gen" >/dev/null 2>>"$ERR"
    check_for_error
}

set_timezone() {
    ZONE=""
    SUBZONE=""
    FULLZONES=$(awk '{print $3}' < /usr/share/zoneinfo/zone.tab)

    if [[ $MANUAL != "True" ]]; then
        GEOI=$(curl --silent freegeoip.net/xml/ | grep -i "TimeZone" | sed 's|<TimeZone>||g')
        GEO=$(sed 's|</TimeZone>||g' <<< "$GEOI" | tr -d '[:blank:]')
    fi

    if ([[ $GEO ]] && grep -qi "$GEO" <<< "$FULLZONES") && [[ $MANUAL != "True" ]]; then
        ZONE=$(awk -F/ '{print $1}' <<< "$GEO")
        SUBZONE=$(awk -F/ '{print $2}' <<< "$GEO")
    else
        for i in $(grep "/" <<< "$FULLZONES" | sed "s|/.*||g" | sort -ud); do
            ZONE="$ZONE $i -"
        done
        dialog --backtitle "$BT" --title " $_ConfBseTimeHC " \
            --menu "$_TimeZBody" 0 0 10 $ZONE 2>$ANS || config_base_menu
        ZONE=$(cat $ANS)

        for i in $(grep "$ZONE/" <<< "$FULLZONES" | sed "s/${ZONE}\///g" | sort -ud); do
            SUBZONE="$SUBZONE $i -"
        done
        dialog --backtitle "$BT" --title " $_ConfBseTimeHC " \
            --menu "$_TimeSubZBody" 0 0 11 $SUBZONE 2>$ANS || config_base_menu
        SUBZONE=$(cat $ANS)
    fi

    if [[ $ZONE ]] && [[ $SUBZONE ]]; then
        title=" $_ConfBseTimeHC "
        msg="$_TimeZQ $ZONE/$SUBZONE?\n\n"
        if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
            arch_chroot "ln -sf /usr/share/zoneinfo/$ZONE/$SUBZONE /etc/localtime" 2>>$ERR
            check_for_error
        else
            MANUAL="True"
            set_timezone
        fi
    else
        MANUAL="True"
        set_timezone
    fi
}

set_hw_clock() {
    arch_chroot "hwclock --systohc --utc"
    if [[ $? -eq 1 ]]; then
        arch_chroot "hwclock --systohc --utc --directisa" 2>>"$ERR"
        if [[ $? -eq 1 ]] && grep -wqi "error" "$ERR"; then
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$(cat "$ERR")" 0 0
            echo "" >$ERR
        fi
    fi
}

set_hostname() {
    HSTNM=$(awk '{print tolower($1)}' <<< "$DIST")
    dialog --backtitle "$BT" --title "$_ConfBseHost" \
        --inputbox "$_HostNameBody" 0 0 "$HSTNM" 2>$ANS || config_base_menu
    HOST_NAME=$(cat $ANS)

    echo "$HOST_NAME" > $MNT/etc/hostname
    echo "127.0.0.1    localhost
127.0.1.1    $HOST_NAME
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters" > $MNT/etc/hosts
}

set_root_password() {
    dialog --backtitle "$BT" --title " $_ConfUsrRoot " --clear --insecure \
        --passwordbox "$_PassRtBody" 0 0 2> $ANS || config_base_menu
    PASSWD=$(cat $ANS)

    dialog --backtitle "$BT" --title " $_ConfUsrRoot " --clear --insecure \
        --passwordbox "$_PassRtBody2" 0 0 2> $ANS || config_base_menu
    PASSWD2=$(cat $ANS)

    if [[ $PASSWD == "$PASSWD2" ]]; then
        echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
        arch_chroot "passwd root" </tmp/.passwd >/dev/null 2>>"$ERR"
        rm /tmp/.passwd
        check_for_error
    else
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        set_root_password
    fi
}

create_new_user() {
    dialog --backtitle "$BT" --title " $_NUsrTitle " \
        --inputbox "$_NUsrBody" 0 0 "" 2>$ANS || config_base_menu
    USER=$(cat $ANS)

    while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do
        dialog --backtitle "$BT" --title " $_NUsrTitle " \
            --inputbox "$_NUsrErrBody" 0 0 "" 2>$ANS || config_base_menu
        USER=$(cat $ANS)
    done

    dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
        --passwordbox "$_PassNUsrBody $USER" 0 0 2>$ANS || config_base_menu
    PASSWD=$(cat $ANS)

    dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
        --passwordbox "$_PassNUsrBody2 $USER" 0 0 2>$ANS || config_base_menu
    PASSWD2=$(cat $ANS)

    while [[ $PASSWD != "$PASSWD2" ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
            --passwordbox "$_PassNUsrBody $USER" 0 0 2>$ANS || config_base_menu
        PASSWD=$(cat $ANS)
        dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
            --passwordbox "$_PassNUsrBody2 $USER" 0 0 2>$ANS || config_base_menu
        PASSWD2=$(cat $ANS)
    done

    dialog --backtitle "$BT" --title " $_ConfUsrNew " --infobox "$_NUsrSetBody" 0 0
    sleep 2
    echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd

    GROUP="rfkill,wheel,autologin,network,lp,storage,power,video,audio,lp"

    # If the first user account, change the live account
    if [[ -e $MNT/home/$ISO_USER ]]; then
        arch_chroot "passwd $ISO_USER" </tmp/.passwd >/dev/null 2>>"$ERR"
        check_for_error

        WHEEL="%wheel ALL=(ALL) ALL"
        OPENBOX="$MNT/home/$ISO_USER/.config/openbox"

        L_FILES=(/etc/lightdm/lightdm.conf
        "/home/$ISO_USER/.config/openbox/autostart"
        /etc/group /etc/gshadow /etc/passwd /etc/shadow
        )

        for f in "${L_FILES[@]}"; do
            sed -i "s/${ISO_USER}/${USER}/g" ${MNT}"$f"
        done

        if grep -q "welcome.sh" $OPENBOX/autostart; then
            sed -i '/welcome.sh/d' $OPENBOX/autostart
        fi
        if grep -q 'item label="ArchLabs Welcome"' $OPENBOX/menu.xml; then
            sed -i '/item label="ArchLabs Welcome"/ i\
    <separator label="ArchLabs"/>' $OPENBOX/menu.xml
            sed -i '/item label="ArchLabs Welcome"/ { N; N; N; N; N; d; }' $OPENBOX/menu.xml
        fi

        if grep -q "archlabs-installer" $OPENBOX/rc.xml; then
            sed -i '/archlabs-installer/ { N; N; d; }' $OPENBOX/rc.xml
        fi
        if grep -q "Install Archlabs" $OPENBOX/menu.xml; then
            sed -i '/Install Archlabs/ { N; N; N; N; N; d; }' $OPENBOX/menu.xml
        fi

        sed -i 's/#$HOME/$HOME/g' $OPENBOX/autostart
        sed -i '/keypack/d' $OPENBOX/autostart
        sed -i '/al-hello/ c sleep 10; termite -e al-hello &' $OPENBOX/autostart

        rm -f $MNT/home/$ISO_USER/.config/keypack
        rm -f $MNT/home/$ISO_USER/bin/welcome.sh

        # Swap live account
        {
            arch_chroot "mv /home/$ISO_USER /home/$USER"
            arch_chroot "chown -R $USER:users /home/$USER"
            arch_chroot "usermod -aG $GROUP $USER"
            sed -i "s/# ${WHEEL}/${WHEEL}/g" $MNT/etc/sudoers
        } 2>>"$ERR"
        check_for_error

    else
        # Create new account
        {
            arch_chroot "useradd $USER -m -g users -G $GROUP -s /bin/zsh"
            arch_chroot "passwd $USER" < /tmp/.passwd >/dev/null
            arch_chroot "cp -R /etc/skel/ /home/$USER"
            arch_chroot "chown -R ${USER}:users /home/$USER"
        } 2>>"$ERR"
        check_for_error
    fi
    rm /tmp/.passwd
}

######################################################################
##              System and Partitioning Functions                   ##
######################################################################

umount_partitions() {
    MOUNTED=""
    MOUNTED=$(mount | grep "$MNT" | awk '{print $3}' | sort -r)
    swapoff -a

    for i in $MOUNTED; do
        umount "$i" >/dev/null 2>>"$ERR"
    done

    check_for_error
}

confirm_mount() {
    local title msg
    title=" $_MntStatusTitle "

    if grep -q "$1" <<< "$(mount)"; then
        dialog --backtitle "$BT" --title "$title" --infobox "$_MntStatusSucc" 0 0
        sleep 2
        PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
        PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
        NUM_PARTS=$((NUM_PARTS - 1))
    else
        dialog --backtitle "$BT" --title "$title" --infobox "$_MntStatusFail" 0 0
        sleep 2
        prep_menu
    fi
}

select_device() {
    DEVICE=""
    dev=$(grep 'disk' <<< "$(lsblk -lno NAME,SIZE,TYPE)")
    dev=$(awk '{print "/dev/" $1 " " $2}' <<< "$dev" | sort -u)

    for i in "${dev[@]}"; do
        DEVS="$DEVS $i"
    done

    if [[ $1 == "Grub" ]]; then
        msg="$_DevSelTitle for Bootloader\n\n$_DevSelBody"
    else
        msg="$_DevSelBody"
    fi

    dialog --backtitle "$BT" --title " $_DevSelTitle " \
        --menu "$msg" 0 0 4 $DEVS 2>$ANS || prep_menu
    DEVICE=$(cat $ANS)
}

find_partitions() {
    PARTS=""
    NUM_PARTS=0
    LBLK=$(lsblk -lno NAME,SIZE,TYPE | grep "$INC_PART" | sed 's/part$/\/dev\//g')
    LBLK=$(sed 's/lvm$\|crypt$/\/dev\/mapper\//g' <<< "$LBLK")
    pts=$(awk '{print $3$1 " " $2}' <<< "$LBLK" | sort -u)

    for i in $pts; do
        PARTS="$PARTS $i"
        NUM_PARTS=$((NUM_PARTS + 1))
    done

    NUM_PARTS=$((NUM_PARTS / 2))

    case $INC_PART in
        'part\|lvm\|crypt')
            if [[ $SYSTEM == "UEFI" ]] && [[ $NUM_PARTS -lt 2 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_partitions
            elif [[ $SYSTEM == "BIOS" ]] && [[ $NUM_PARTS -eq 0 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_partitions
            fi ;;
        'part\|crypt')
            if [[ $NUM_PARTS -eq 0 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmPartErrBody" 0 0
                create_partitions
            fi ;;
        'part\|lvm')
            if [[ $NUM_PARTS -lt 2 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LuksPartErrBody" 0 0
                create_partitions
            fi
    esac
}

create_partitions() {
    secure_wipe() {
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dialog --backtitle "$BT" --title " $_PartOptWipe " --yesno "$msg" 0 0; then
            clear ; echo -e "Secure wiping $DEVICE this will take a while.."
            wipe -Ifre "$DEVICE"
        else
            create_partitions
        fi
    }

    auto_partition() {
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"

        if dialog --backtitle "$BT" --title " $_PrepPartDisk " --yesno "$msg" 0 0; then
            parted -s "$DEVICE" print | awk '/^ / {print $1}' >/tmp/.del_parts

            for del_part in $(tac /tmp/.del_parts); do
                parted -s "$DEVICE" rm "$del_part" 2>>"$ERR"
                check_for_error
            done

            table=$(parted -s "$DEVICE" print | grep -i 'partition table' | awk '{print $3}')

            if ([[ $SYSTEM == "BIOS" ]] && [[ $table != "msdos" ]]); then
                parted -s "$DEVICE" mklabel msdos 2>>"$ERR"
            elif ([[ $SYSTEM == "UEFI" ]] && [[ $table != "gpt" ]]); then
                parted -s "$DEVICE" mklabel gpt 2>>"$ERR"
            fi
            check_for_error

            if [[ $SYSTEM == "BIOS" ]]; then
                parted -s "$DEVICE" mkpart primary ext4 1MiB 513MiB 2>>"$ERR"
            else
                parted -s "$DEVICE" mkpart ESP fat32 1MiB 513MiB 2>>"$ERR"
            fi

            parted -s "$DEVICE" set 1 boot on 2>>"$ERR"
            parted -s "$DEVICE" mkpart primary ext4 513MiB 100% 2>>"$ERR"
            check_for_error

            lsblk "$DEVICE" -o NAME,TYPE,FSTYPE,SIZE >/tmp/.devlist
            dialog --backtitle "$BT" --title "" --textbox /tmp/.devlist 0 0
        else
            create_partitions
        fi
    }

    dialog --backtitle "$BT" --title "$_PartToolTitle" --menu "$_PartToolBody" 0 0 5 \
        "$_PartOptWipe" "BIOS & UEFI" \
        "$_PartOptAuto" "BIOS & UEFI" \
        "gparted"       "BIOS & UEFI" \
        "cfdisk"        "BIOS/MBR" \
        "parted"        "UEFI/GPT" 2>$ANS
    clear

    if [[ $(cat $ANS) != "" ]]; then
        if [[ $(cat $ANS) != "$_PartOptWipe" ]] && [[ $(cat $ANS) != "$_PartOptAuto" ]]; then
            $(cat $ANS) "$DEVICE"
        else
            [[ $(cat $ANS) == "$_PartOptWipe" ]] && secure_wipe && create_partitions
            [[ $(cat $ANS) == "$_PartOptAuto" ]] && auto_partition
        fi
    fi
}

select_filesystem() {
    fs_opts="" CHK_NUM=0
    dialog --backtitle "$BT" --title " $_FSTitle " --menu "$_FSBody" 0 0 12 \
        "$_FSSkip" "-" \
        "btrfs"    "mkfs.btrfs -f" \
        "ext2"     "mkfs.ext2 -q" \
        "ext3"     "mkfs.ext3 -q" \
        "ext4"     "mkfs.ext4 -q" \
        "f2fs"     "mkfs.f2fs" \
        "jfs"      "mkfs.jfs -q" \
        "nilfs2"   "mkfs.nilfs2 -q" \
        "ntfs"     "mkfs.ntfs -q" \
        "reiserfs" "mkfs.reiserfs -q" \
        "vfat"     "mkfs.vfat -F32" \
        "xfs"      "mkfs.xfs -f" 2>$ANS

    case "$(cat $ANS)" in
        "$_FSSkip")
            FS="$_FSSkip"
            ;;
        "btrfs")
            FS="mkfs.btrfs -f" CHK_NUM=16
            fs_opts=(
            autodefrag "compress=zlib" "compress=lzo" "compress=no"
            "compress-force=zlib" "compress-force=lzo" discard noacl
            noatime nodatasum nospace_cache recovery skip_balance
            space_cache ssd ssd_spread
            )
            modprobe btrfs
            ;;
        "ext2")
            FS="mkfs.ext2 -q"
            ;;
        "ext3")
            FS="mkfs.ext3 -q"
            ;;
        "ext4")
            FS="mkfs.ext4 -q" CHK_NUM=8
            fs_opts=(
            "data=journal" "data=writeback" dealloc
            discard noacl noatime nobarrier nodelalloc
            )
            ;;
        "f2fs")
            FS="mkfs.f2fs"
            CHK_NUM=16
            fs_opts=(
            data_flush disable_roll_forward disable_ext_identify
            discard fastboot flush_merge inline_xattr inline_data
            inline_dentry no_heap noacl nobarrier noextent_cache
            noinline_data norecovery
            )
            modprobe f2fs
            ;;
        "jfs")
            FS="mkfs.jfs -q" CHK_NUM=4
            fs_opts=(discard "errors=continue" "errors=panic" nointegrity)
            ;;
        "nilfs2")
            FS="mkfs.nilfs2 -q" CHK_NUM=7
            fs_opts=(
            discard nobarrier "errors=continue" "errors=panic"
            "order=relaxed" "order=strict" norecovery
            )
            ;;
        "ntfs")
            FS="mkfs.ntfs -q"
            ;;
        "reiserfs")
            FS="mkfs.reiserfs -q" CHK_NUM=5
            fs_opts=(acl nolog notail replayonly user_xattr)
            ;;
        "vfat")
            FS="mkfs.vfat -F32"
            ;;
        "xfs")
            FS="mkfs.xfs -f" CHK_NUM=9
            fs_opts=(
            discard filestreams ikeep largeio noalign
            nobarrier norecovery noquota wsync
            )
            ;;
        *) prep_menu
    esac

    if [[ $FS != "$_FSSkip" ]]; then
        msg="\n$FS $PART\n\n"
        if dialog --backtitle "$BT" --title " $_FSTitle " --yesno "$msg" 0 0; then
            $FS "$PART" >/dev/null 2>>"$ERR"
            check_for_error
        else
            select_filesystem
        fi
    fi
}

mount_partitions() {
    mount_opts() {
        FS_OPTS=""
        local title msg
        echo "" > $MOUNT_OPTS

        for i in "${fs_opts[@]}"; do
            FS_OPTS="$FS_OPTS $i - off"
        done

        title=" $(sed "s/.*\.//g" <<< "$FS" | sed "s/-.*//g") "
        dialog --backtitle "$BT" --title "$title" \
            --checklist "$_MntBody" 0 0 $CHK_NUM $FS_OPTS 2>$MOUNT_OPTS

        sed -i 's/ /,/g' $MOUNT_OPTS
        sed -i '$s/,$//' $MOUNT_OPTS

        if [[ $(cat $MOUNT_OPTS) != "" ]]; then
            msg="${_MntConfBody}$(cat $MOUNT_OPTS)\n"
            title=" $_MntStatusTitle "
            if ! dialog --backtitle "$BT" --title "$title" --yesno "$msg" 10 75; then
                mount_opts
            fi
        fi
    }

    mount_current_partition() {
        mkdir -p "${MNT}$MOUNT" 2>>"$ERR"
        [[ ${fs_opts[*]} != "" ]] && mount_opts


        if [[ $(cat $MOUNT_OPTS) != "" ]]; then
            mount -o $(cat $MOUNT_OPTS) "$PART" "${MNT}$MOUNT" 2>>"$ERR"
        else
            mount "$PART" "${MNT}$MOUNT" 2>>"$ERR"
        fi
        check_for_error
        confirm_mount "${MNT}$MOUNT"

        BLK=$(lsblk -lno NAME,FSTYPE,TYPE)

        # Identify if mounted partition is "crypt" (LUKS on LVM, or LUKS alone)
        if grep -q "crypt" <<< "$(lsblk -lno TYPE "$PART")"; then

            LUKS=1
            LUKS_NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")

            cryptblk=$(grep "lvm" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$cryptblk" | uniq)

            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    if [[ $LUKS_DEV ]]; then
                        LUKS_DEV="$LUKS_DEV cryptdevice=$i:$LUKS_NAME"
                    else
                        LUKS_DEV="cryptdevice=$i:$LUKS_NAME"
                    fi
                    LVM=1
                    break
                fi
            done

            cryptblk=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$cryptblk" | uniq)

            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    if [[ $LUKS_DEV ]]; then
                        LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    else
                        LUKS_DEV="cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    fi
                    break
                fi
            done

        elif grep -q "lvm" "$(lsblk -lno TYPE "$PART")"; then

            LVM=1
            NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")

            cryptblk=$(grep "crypt" <<< "$BLK" | grep -i "lvm2_member")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$cryptblk" | uniq)

            for i in ${crypts}; do
                if grep -q "$NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_NAME=$(sed s~/dev/mapper/~~g <<< "$i")
                    break
                fi
            done

            cryptblk=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$cryptblk" | uniq)

            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')

                    if ! grep -q "$LUKS_UUID" <<< "$LUKS_DEV"; then
                        LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                        LUKS=1
                    fi
                    break
                fi
            done
        fi
    }

    make_swap() {
        dialog --backtitle "$BT" --title " $_PrepMntPart " \
            --menu "$_SelSwpBody" 0 0 7 \
            "$_SelSwpNone" $"-" \
            "$_SelSwpFile" $"-" \
            $PARTS 2>$ANS || prep_menu

        if [[ $(cat $ANS) != "$_SelSwpNone" ]]; then
            PART=$(cat $ANS)

            if [[ $PART == "$_SelSwpFile" ]]; then
                mem=$(grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//')
                dialog --backtitle "$BT" --title " $_SelSwpFile " \
                    --inputbox "\nM = MB, G = GB\n" 9 30 "${mem}M" 2>$ANS || make_swap
                m_or_g=$(cat $ANS)

                while [[ $(echo ${m_or_g: -1} | grep "M\|G") == "" ]]; do
                    msg="\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n"
                    dialog --backtitle "$BT" --title " $_SelSwpFile " --msgbox "$msg" 0 0
                    dialog --backtitle "$BT" --title " $_SelSwpFile " \
                        --inputbox "\nM = MB, G = GB\n" 9 30 "${mem}M" 2>$ANS || make_swap
                    m_or_g=$(cat $ANS)
                done

                fallocate -l "$m_or_g" $MNT/swapfile 2>>"$ERR"
                chmod 600 $MNT/swapfile 2>>"$ERR"
                mkswap $MNT/swapfile >/dev/null 2>>"$ERR"
                swapon $MNT/swapfile >/dev/null 2>>"$ERR"
                check_for_error
            else
                if [[ $(lsblk -o FSTYPE "$PART" | grep -i "swap") != "swap" ]]; then
                    title=" $_PrepMntPart " msg="\nmkswap $PART\n\n"
                    if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
                        mkswap "$PART" >/dev/null 2>>"$ERR"
                    else
                        mount_partitions
                    fi
                fi
                swapon "$PART" >/dev/null 2>>"$ERR"
                check_for_error
                PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
                PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
                NUM_PARTS=$((NUM_PARTS - 1))
            fi
        fi
    }

    #                                            #
    #  Find partitions and run mounting dialogs  #
    #                                            #

    MOUNT=""
    LUKS_NAME=""
    LUKS_DEV=""
    LUKS_UUID=""
    LUKS=0
    LVM=0

    dialog --backtitle "$BT" --title " $_PrepMntPart " \
        --msgbox "$_WarnMount1 '$_FSSkip' $_WarnMount2" 0 0

    lvm_detect
    INC_PART='part\|lvm\|crypt'

    umount_partitions
    find_partitions

    dialog --backtitle "$BT" --title " $_PrepMntPart " \
        --menu "$_SelRootBody" 0 0 7 $PARTS 2>$ANS || prep_menu
    PART=$(cat $ANS)
    ROOT_PART=$PART

    select_filesystem
    mount_current_partition
    make_swap

    # Extra Step for VFAT EFI Partition.. Not in an LVM container.
    if [[ $SYSTEM == "UEFI" ]]; then
        dialog --backtitle "$BT" --title " $_PrepMntPart " \
            --menu "$_SelUefiBody" 0 0 7 $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        if grep -q 'fat' <<< "$(fsck -N "$PART")"; then
            local title=" $_PrepMntPart "
            local msg="$_FormUefiBody $PART $_FormUefiBody2"
            if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
                mkfs.vfat -F32 "$PART" >/dev/null 2>>"$ERR"
            fi
        else
            mkfs.vfat -F32 "$PART" >/dev/null 2>>"$ERR"
        fi
        check_for_error
        mkdir -p ${MNT}$EFI_MNT 2>>"$ERR"
        mount "$PART" ${MNT}$EFI_MNT 2>>"$ERR"
        check_for_error
        confirm_mount ${MNT}$EFI_MNT
    fi

    # leftover partitions
    while [[ $NUM_PARTS -gt 0 ]]; do
        dialog --backtitle "$BT" --title " $_PrepMntPart " \
            --menu "$_ExtPartBody" 0 0 7 "$_Done" $"-" $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        if [[ $PART == "$_Done" ]]; then
            break
        else
            MOUNT=""
            select_filesystem
            if [[ $SYSTEM == "UEFI" ]]; then
                MNT_EXAMPLES="/home /var"
            else
                MNT_EXAMPLES="/boot /home /var"
            fi

            dialog --backtitle "$BT" --title " $_PrepMntPart $PARTITON " \
                --inputbox "$_ExtPartBody1$MNT_EXAMPLES\n" 0 0 "/" 2>$ANS || prep_menu
            MOUNT=$(cat $ANS)

            while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
                dialog --backtitle "$BT" --title " $_PrepMntPart $PARTITON " \
                    --inputbox "${_ExtPartBody1}$MNT_EXAMPLES\n" 0 0 "/" 2>$ANS || prep_menu
                MOUNT=$(cat $ANS)
            done
            mount_current_partition

            if [[ $MOUNT == "/usr" ]]; then
                if [[ $MNTHOOKS ]]; then
                    if ! grep -q "usr shutdown" <<< "$MNTHOOKS"; then
                        MNTHOOKS="$MNTHOOKS usr shutdown"
                    fi
                else
                    MNTHOOKS="usr shutdown"
                fi
            fi

            if [[ $MOUNT == "/boot" ]]; then
                if grep -q "lvm" <<< "$(lsblk -lno TYPE "$PART")"; then
                    LVM_SEP_BOOT=2
                else
                    LVM_SEP_BOOT=1
                fi
            fi
        fi
    done
}

######################################################################
##             Encryption (dm_crypt) Functions                      ##
######################################################################

luks_password() {
    dialog --backtitle "$BT" --title " $_PrepLUKS " --clear --insecure \
        --passwordbox "$_LuksPassBody" 0 0 2> $ANS || prep_menu
    PASSWD=$(cat $ANS)

    dialog --backtitle "$BT" --title " $_PrepLUKS " --clear --insecure \
        --passwordbox "$_PassNUsrBody2 $LUKS_ROOT_NAME" 0 0 2> $ANS || prep_menu
    PASSWD2=$(cat $ANS)

    if [[ $PASSWD != "$PASSWD2" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        luks_password
    else
        LUKS_PASSWD="$PASSWD"
    fi
}

luks_open() {
    LUKS_ROOT_NAME="" INC_PART='part\|crypt\|lvm'
    umount_partitions
    find_partitions

    dialog --backtitle "$BT" --title " $_LuksOpen " \
        --menu "$_LuksMenuBody" 0 0 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)

    dialog --backtitle "$BT" --title " $_LuksOpen " \
        --inputbox "$_LuksOpenBody" 10 50 "cryptroot" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password

    local msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
    dialog --backtitle "$BT" --title " $_LuksOpen " --infobox "$msg" 0 0
    echo "$PASSWD" | cryptsetup open --type luks "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
}

luks_setup() {
    modprobe -a dm-mod dm_crypt
    INC_PART='part\|lvm'
    umount_partitions
    find_partitions
    dialog --backtitle "$BT" --title " $_LuksEncrypt " \
        --menu "$_LuksEncryptBody" 0 0 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)

    dialog --backtitle "$BT" --title " $_LuksEncrypt " \
        --inputbox "$_LuksOpenBody" 0 0 "cryptroot" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
}

luks_default() {
    local msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
    dialog --backtitle "$BT" --title " $_LuksEncrypt " --infobox "$msg" 0 0

    sleep 1
    echo "$PASSWD" | cryptsetup -q luksFormat "$PART" 2>"$ERR"
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
}

luks_key_define() {
    dialog --backtitle "$BT" --title " $_PrepLUKS " \
        --inputbox "$_LuksCipherKey" 0 0 "-s 512 -c aes-xts-plain64" 2>$ANS || luks_menu

    local msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
    dialog --backtitle "$BT" --title " $_LuksEncryptAdv " --infobox "$msg" 0 0
    sleep 1

    echo "$PASSWD" | cryptsetup -q "$(cat $ANS)" luksFormat "$PART" 2>"$ERR"
    check_for_error
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
}

luks_show(){
    echo -e "$_LuksEncryptSucc" >/tmp/.devlist
    lsblk -o NAME,TYPE,FSTYPE,SIZE "$PART" \
        | grep "part\|crypt\|NAME\|TYPE\|FSTYPE\|SIZE" >>/tmp/.devlist
    dialog --backtitle "$BT" --title " $_LuksEncrypt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_menu() {
    local msg="$_LuksMenuBody$_LuksMenuBody2$_LuksMenuBody3"
    dialog --backtitle "$BT" --title " $_PrepLUKS " --menu "$msg" 0 0 4 \
        "$_LuksOpen"       "cryptsetup open --type luks" \
        "$_LuksEncrypt"    "cryptsetup -q luksFormat" \
        "$_LuksEncryptAdv" "cryptsetup -q -s -c luksFormat" \
        "$_Back" "-" 2>$ANS

    case "$(cat $ANS)" in
        "$_LuksOpen")       luks_open  ; luks_show ;;
        "$_LuksEncrypt")    luks_setup ; luks_default    ; luks_show ;;
        "$_LuksEncryptAdv") luks_setup ; luks_key_define ; luks_show ;;
        *) prep_menu
    esac

    luks_menu
}

######################################################################
##             Logical Volume Management Functions                  ##
######################################################################

lvm_detect() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)

    if [[ $LV != "" ]] && [[ $LV_VG != "" ]] && [[ $LVM_PV != "" ]]; then
        dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>>"$ERR"
        check_for_error
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

lvm_show_vg() {
    VG_LIST=""
    list=$(lvs --noheadings | awk '{print $2}' | uniq)

    for i in $list; do
        size=$(vgdisplay "$i" | grep -i "vg size" | awk '{print $3$4}')
        VG_LIST="$VG_LIST $i $size"
    done

    if [[ $VG_LIST == "" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmVGErr" 0 0
        lvm_menu
    fi

    local title=" $_PrepLVM "
    local msg="$_LvmSelVGBody"
    dialog --backtitle "$BT" --title "$title" --menu "$msg" 0 0 5 $VG_LIST 2>$ANS || lvm_menu
}

lvm_create() {
    check_lv_size() {
        LV_SIZE_INVALID=0

        local chars=0
        local n=${#LV_SIZE}
        local ln=${LV_SIZE:0:1}
        local lv=$((${#LV_SIZE} - 1))

        if [[ $n -eq 0 ]] || [[ $ln -eq "0" ]]; then
            LV_SIZE_INVALID=1
        fi

        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            while [[ $chars -lt $lv ]]; do
                if [[ ${LV_SIZE:chars:1} != [0-9] ]]; then
                    LV_SIZE_INVALID=1
                    break
                fi
                chars=$((chars + 1))
            done
        fi

        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            LV_SIZE_TYPE=${LV_SIZE:$lv:1}
            case $LV_SIZE_TYPE in
                "m"|"M"|"g"|"G") LV_SIZE_INVALID=0 ;;
                *)               LV_SIZE_INVALID=1
            esac
        fi

        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            case $LV_SIZE_TYPE in
                "G"|"g")
                    if [[ $((${LV_SIZE:0:$lv} * 1000)) -ge $LV_VG_MB ]]; then
                        LV_SIZE_INVALID=1
                    else
                        LV_VG_MB=$((LV_VG_MB - $((${LV_SIZE:0:$lv} * 1000))))
                    fi ;;
                "M"|"m")
                    if [[ ${LV_SIZE:0:$LESS1} -ge $LV_VG_MB ]]; then
                        LV_SIZE_INVALID=1
                    else
                        LV_VG_MB=$((LV_VG_MB - ${LV_SIZE:0:$lv}))
                    fi ;;
                *) LV_SIZE_INVALID=1
            esac
        fi
    }

    LV_VG=""
    VG_PARTS=""
    LV_VG_MB=0
    INC_PART='part\|crypt'
    umount_partitions
    find_partitions
    PARTS=$(sed 's/M\|G\|T/& off/g' <<< "$PARTS")

    local msg="$_LvmNameVgBody"
    local title=" $_LvmCreateVG "
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
    LV_VG=$(cat $ANS)

    local n=${#LV_VG}
    local ln=${LV_VG:0:1}
    local has
    has=$(grep -q "$LV_VG" <<< "$(lsblk)")
    while [[ $ln == "/" ]] || [[ $n -eq 0 ]] || [[ $LV_VG =~ \ |\' ]] || [[ $has ]]; do
        dialog --backtitle "$BT" --title "$_ErrTitle" --msgbox "$_LvmNameVgErr" 0 0
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
        LV_VG=$(cat $ANS)
    done

    msg="$_LvmPvSelBody $_UseSpaceBar"
    dialog --backtitle "$BT" --title "$title" --checklist "$msg" 0 0 7 $PARTS 2>$ANS || prep_menu
    if [[ $(cat $ANS) != "" ]]; then
        VG_PARTS=$(cat $ANS)
    else
        prep_menu
    fi

    msg="$_LvmPvConfBody1${LV_VG} $_LvmPvConfBody2${VG_PARTS}"
    if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
        msg="$_LvmPvActBody1${LV_VG}.$_PlsWaitBody"
        dialog --backtitle "$BT" --title "$title" --infobox "$msg" 0 0
        sleep 1
        vgcreate -f "$LV_VG" "$VG_PARTS" >/dev/null 2>>"$ERR"
        check_for_error

        VG_SIZE=$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $3}' | sed 's/\..*//')
        VG_SIZE_TYPE=$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $4}')
        if [[ ${VG_SIZE_TYPE:0:1} == "G" ]]; then
            LV_VG_MB=$((VG_SIZE * 1000))
        else
            LV_VG_MB=$VG_SIZE
        fi

        msg="$_LvmPvDoneBody1 '$LV_VG' $_LvmPvDoneBody2 ($VG_SIZE $VG_SIZE_TYPE)."
        dialog --backtitle "$BT" --title "$title" --msgbox "$msg" 0 0
    else
        lvm_menu
    fi

    msg="$_LvmLvNumBody1 $LV_VG. $_LvmLvNumBody2"
    dialog --backtitle "$BT" --title "$title" --radiolist "$msg" 0 0 9 \
        "1" "-" off \
        "2" "-" off \
        "3" "-" off \
        "4" "-" off \
        "5" "-" off \
        "6" "-" off \
        "7" "-" off \
        "8" "-" off \
        "9" "-" off 2>$ANS
    if [[ $(cat $ANS) == "" ]]; then
        lvm_menu
    else
        NUM_LVS=$(cat $ANS)
    fi

    while [[ $NUM_LVS -gt 1 ]]; do
        title=" $_LvmCreateVG (LV:$NUM_LVS) "
        msg="$_LvmLvNameBody1"
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
        LV_NAME=$(cat $ANS)

        ln=${LV_NAME:0:1}
        n=${#LV_NAME}
        has=$(grep -q "$LV_NAME" <<< "$(lsblk)")
        while [[ $ln == "/" ]] || [[ $n -eq 0 ]] || [[ $LV_NAME =~ \ |\' ]] || [[ $has ]]; do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
            dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
            LV_NAME=$(cat $ANS)
        done

        msg="${LV_VG}: ${VG_SIZE}$VG_SIZE_TYPE (${LV_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
        LV_SIZE=$(cat $ANS)
        check_lv_size

        while [[ $LV_SIZE_INVALID -eq 1 ]]; do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvSizeErrBody" 0 0
            dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
            LV_SIZE=$(cat $ANS)
            check_lv_size
        done

        lvcreate -L "$LV_SIZE" "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
        check_for_error

        msg="$_Done LV $LV_NAME ($LV_SIZE) $_LvmPvDoneBody2."
        dialog --backtitle "$BT" --title "$title" --msgbox "$msg" 0 0
        NUM_LVS=$((NUM_LVS - 1))
    done

    title=" $_LvmCreateVG (LV:$NUM_LVS) "
    msg="$_LvmLvNameBody1 $_LvmLvNameBody2 (${LV_VG_MB}MB)."
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
    LV_NAME=$(cat $ANS)

    ln=${LV_NAME:0:1}
    n=${#LV_NAME}
    has=$(grep -q "$LV_NAME" <<< "$(lsblk)")
    while [[ $ln == "/" ]] || [[ $n -eq 0 ]] || [[ $LV_NAME =~ \ |\' ]] || [[ $has ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
        LV_NAME=$(cat $ANS)
    done

    lvcreate -l +100%FREE "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
    check_for_error
    NUM_LVS=$((NUM_LVS - 1))
    LVM=1

    title=" $_LvmCreateVG "
    msg="$_LvmCompBody"
    if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
        show_devices
    else
        lvm_menu
    fi
}

lvm_del_vg() {
    lvm_show_vg
    if dialog --backtitle "$BT" --title " $_LvmDelVG " --yesno "$_LvmDelQ" 0 0; then
        vgremove -f "$(cat $ANS)" >/dev/null 2>&1
    fi
    lvm_menu
}

lvm_del_all() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)

    if dialog --backtitle "$BT" --title " $_LvMDelAll " --yesno "$_LvmDelQ" 0 0; then
        for i in $LV; do lvremove -f "/dev/mapper/$i" >/dev/null 2>&1; done
        for i in $LV_VG; do vgremove -f "$i" >/dev/null 2>&1; done
        for i in $LVM_PV; do pvremove -f "$i" >/dev/null 2>&1; done
    fi
    lvm_menu
}

lvm_menu() {
    dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "$_PlsWaitBody" 0 0
    sleep 1
    lvm_detect

    dialog --backtitle "$BT" --title " $_PrepLVM " --menu "$_LvmMenu" 0 0 4 \
        "$_LvmCreateVG" "vgcreate -f, lvcreate -L -n" \
        "$_LvmDelVG"    "vgremove -f" \
        "$_LvMDelAll"   "lvrmeove, vgremove, pvremove -f" \
        "$_Back" "-" 2>$ANS

    case "$(cat $ANS)" in
        "$_LvmCreateVG") lvm_create  ;;
        "$_LvmDelVG")    lvm_del_vg  ;;
        "$_LvMDelAll")   lvm_del_all ;;
        *)               prep_menu
    esac
}

######################################################################
##                    Installation Functions                        ##
######################################################################

install_root() {
    clear
    if [[ -e $IMG ]]; then
        rsync -a --progress $IMG $MNT/ 2>>"$ERR"
        check_for_error
    else
        echo -e "IMG has not been properly configured... Exiting" ; exit 1
    fi

    local rfiles=(
    "$BYPASS" "/archlabs-installer" "/etc/sudoers.d/g_wheel"
    "/etc/mkinitcpio-archiso.conf" "/usr/bin/install-al"
    "/etc/polkit-1/rules.d/49-nopasswd_global.rules"
    )

    for f in "${rfiles[@]}"; do
        rm -rf ${MNT}"$f"
    done

    find $MNT/usr/lib/initcpio -name archiso* -type f -exec rm '{}' \;

    local autostart="$MNT/etc/skel/.config/openbox/autostart"
    sed -i '/al-hello/ c sleep 10; termite --exec=/usr/bin/al-hello &' $autostart
    sed -i 's|#$HOME/.config/setup &|$HOME/.config/setup &|g' $autostart
    sed -i 's/volatile/auto/g' $MNT/etc/systemd/journald.conf

    local bootimg="/run/archiso/bootmnt/arch/boot/$ARCHI/vmlinuz"
    cp -f "$bootimg" $MNT/boot/vmlinuz-linux 2>>"$ERR"
    check_for_error

    # Console & Keyboard files
    [[ -e /tmp/keyboard ]] && cp -f /tmp/keyboard $MNT/etc/default/keyboard
    [[ -e /tmp/01-keyboard.conf ]] && cp -f /tmp/01-keyboard.conf $MNT/etc/X11/xorg.conf.d/01-keyboard.conf
    [[ -e /tmp/vconsole.conf ]] && cp -f /tmp/vconsole.conf $MNT/etc/vconsole.conf

    # Setup mirrorlist
    reflector --score 50 --fastest 10 --sort rate --save $MNT/etc/pacman.d/mirrorlist --verbose

    # initialize pacman keyring
    arch_chroot "mkdir -p /var/lib/pacman/sync"
    arch_chroot "touch /var/lib/pacman/sync/{core.db,extra.db,community.db}"
    arch_chroot "dirmngr </dev/null"
    arch_chroot "gpg --receive-keys C1A60EACE707FDA5"
    arch_chroot "pacman-key --init && pacman-key --populate archlinux"

    local keys=(
    'AEFB411B072836CD48FF0381AE252C284B5DBA5D'
    '9E4F11C6A072942A7B3FD3B0B81EB14A09A25EB0'
    '35F52A02854DCCAEC9DD5CC410443C7F54B00041'
    )

    for i in "${keys[@]}"; do
        arch_chroot "gpg --receive-keys $i"
        arch_chroot "pacman-key -r $i"
        arch_chroot "pacman-key --lsign $i"
    done
    arch_chroot "pacman-key --populate archlabs"
    arch_chroot "pacman -Syyu --noconfirm"

    # System services
    arch_chroot "systemctl enable ntpd.service -f"
    arch_chroot "systemctl enable NetworkManager.service -f"
    arch_chroot "systemctl enable lightdm.service -f"

    # Additional packages
    arch_chroot "pacman -S iputils --noconfirm"
    arch_chroot "pacman -S base-devel --needed --noconfirm"
}

install_bootloader() {
    grub_configuration() {
        local CFG="$MNT/etc/default/grub"
        sed -i "s/GRUB_DISTRIBUTOR=.*/GRUB_DISTRIBUTOR=\"${DIST}\"/g" $CFG

        if [[ $LUKS_DEV ]]; then
            sed -i "s~GRUB_CMDLINE_LINUX=\"\"~GRUB_CMDLINE_LINUX=\"${LUKS_DEV}\"~g" $CFG
            sed -i "s/#GRUB_ENABLE_CRYPTODISK=y/GRUB_ENABLE_CRYPTODISK=y/g" $CFG
        fi

        if [[ $SYSTEM == "BIOS" ]]; then
            if ([[ $LVM -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]]) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
                sed -i "s/GRUB_PRELOAD_MODULES=.*/GRUB_PRELOAD_MODULES=\"lvm\"/g" $CFG
            fi
        fi
    }

    bios_bootloader() {
        select_device "Grub"
        grub_configuration
        arch_chroot "grub-install --target=i386-pc --recheck --force $DEVICE" 2>>$ERR
        check_for_error
    }

    uefi_bootloader() {
        if grep -q "/sys/firmware/efi/efivars" <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        grub_configuration
        CMD="grub-install --target=x86_64-efi --efi-directory=$EFI_MNT --bootloader-id=$DIST --force"
        arch_chroot "$CMD" 2>>"$ERR"

        local efi_dirs
        efi_dirs=($(find ${MNT}$EFI_MNT/EFI -maxdepth 1 -type d))
        for i in "${efi_dirs[@]}"; do
            name=$(basename "$i")
            if [[ $name == "BOOT" ]] || [[ $name == "Boot" ]] || [[ $name == "boot" ]]; then
                BOOTDIR=$EFI_MNT/EFI/$name
                break
            else
                BOOTDIR=$EFI_MNT/EFI/boot
            fi
        done
        mkdir -p $MNT/$BOOTDIR
        arch_chroot "cp -rf $EFI_MNT/EFI/$DIST/grubx64.efi $BOOTDIR/grubx64.efi"
        arch_chroot "cp -rf $EFI_MNT/EFI/$DIST/grubx64.efi $BOOTDIR/bootx64.efi"
        check_for_error
    }

    check_mount
    arch_chroot "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/core_perl" 2>>$ERR
    check_for_error

    if [[ $SYSTEM == "BIOS" ]]; then
        bios_bootloader
    else
        uefi_bootloader
    fi

    os-prober &>/dev/null
    arch_chroot "os-prober" &>/dev/null
    arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>$ERR
    check_for_error
}

install_base_system() {
    install_root

    # FSTAB
    genfstab -U -p $MNT > $MNT/etc/fstab 2>>"$ERR"
    check_for_error
    if [[ -f $MNT/swapfile ]]; then
        sed -i "s/\\${MNT}//" $MNT/etc/fstab
    fi

    run_mkinitcpio
    install_bootloader
    config_base_menu
}

run_mkinitcpio() {
    clear
    local conf="$MNT/etc/mkinitcpio.conf"

    if [[ $LVM -eq 1 ]] && [[ $LUKS -eq 0 ]]; then
        sed -i 's/block filesystems/block lvm2 filesystems/g' $conf 2>>"$ERR"
    elif [[ $LVM -eq 1 ]] && [[ $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' $conf 2>>"$ERR"
    elif [[ $LVM -eq 0 ]] && [[ $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt filesystems/g' $conf 2>>"$ERR"
    fi

    local dev
    if [[ $LUKS_DEV ]]; then
        sed -i 's/block filesystems/block encrypt filesystems/g' $conf 2>>"$ERR"
        if [[ $LUKS_PASSWD ]] && [[ $LUKS_UUID ]]; then
            dev=$(lsblk -lno NAME,UUID,TYPE | grep "part")
            dev="/dev/$(grep "$LUKS_UUID" <<< "$dev" | awk '{print $1}')"
            arch_chroot "dd bs=512 count=8 if=/dev/urandom of=/crypto_keyfile.bin" &>/dev/null
            arch_chroot "chmod 000 /crypto_keyfile.bin"
            echo "INFO: Setting up single password decryption at boot"
            echo "INFO: Creating encryption keyfile: /crypto_keyfile.bin"
            arch_chroot "echo '$LUKS_PASSWD' | cryptsetup luksAddKey $dev /crypto_keyfile.bin"
            sed -i 's/FILES=()/FILES=(\/crypto_keyfile.bin)/g' $conf
        fi
    fi

    if [[ $MNTHOOKS ]]; then
        sed -i "s/keyboard fsck/keyboard ${MNTHOOKS} fsck/g" $conf 2>>"$ERR"
    fi

    arch_chroot "mkinitcpio -p linux" 2>>"$ERR"
    check_for_error
}

######################################################################
##                       Menu Interfaces                            ##
######################################################################

security_menu() {
    if [[ $SUB_MENU != "security_menu" ]]; then
        SUB_MENU="security_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 4 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi

    dialog --default-item $HIGHLIGHT --backtitle "$BT" \
        --title " $_SecMenuTitle " --menu "$_SecMenuBody" 0 0 4 \
        "1" "$_SecJournTitle" \
        "2" "$_SecCoreTitle" \
        "3" "$_SecKernTitle" \
        "4" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)

    case "$(cat $ANS)" in
        "1")
            dialog --backtitle "$BT" --title " $_SecJournTitle " --menu "$_SecJournBody" 0 0 7 \
                "$_Edit" "/etc/systemd/journald.conf" \
                "10M"  "SystemMaxUse=10M" \
                "20M"  "SystemMaxUse=20M" \
                "50M"  "SystemMaxUse=50M" \
                "100M" "SystemMaxUse=100M" \
                "200M" "SystemMaxUse=200M" \
                "$_Disable" "Storage=none" 2>$ANS
            if [[ $(cat $ANS) != "" ]]; then
                if  [[ $(cat $ANS) == "$_Disable" ]]; then
                    sed -i "s/#Storage.*\|Storage.*/Storage=none/g" $MNT/etc/systemd/journald.conf
                    sed -i "s/SystemMaxUse.*/#&/g" $MNT/etc/systemd/journald.conf
                    dialog --backtitle "$BT" --title " $_SecJournTitle " --infobox "$_Done!" 0 0
                    sleep 2
                elif [[ $(cat $ANS) == "$_Edit" ]]; then
                    nano $MNT/etc/systemd/journald.conf
                else
                    sed -i "s/#Storage.*\|Storage.*/Storage=$(cat $ANS)/g" $MNT/etc/systemd/journald.conf
                    sed -i "s/SystemMaxUse.*/#&/g" $MNT/etc/systemd/journald.conf
                    dialog --backtitle "$BT" --title " $_SecJournTitle " --infobox "$_Done!" 0 0
                    sleep 2
                fi
            fi ;;
        "2")
            dialog --backtitle "$BT" --title " $_SecCoreTitle " --menu "$_SecCoreBody" 0 0 2 \
                "$_Disable" "Storage=none" \
                "$_Edit"    "/etc/systemd/coredump.conf" 2>$ANS
            if [[ $(cat $ANS) == "$_Disable" ]]; then
                sed -i "s/#Storage.*\|Storage.*/Storage=none/g" $MNT/etc/systemd/coredump.conf
                dialog --backtitle "$BT" --title " $_SecCoreTitle " --infobox "$_Done!" 0 0
                sleep 2
            elif [[ $(cat $ANS) == "$_Edit" ]]; then
                nano $MNT/etc/systemd/coredump.conf
            fi ;;
        "3")
            dialog --backtitle "$BT" --title " $_SecKernTitle " --menu "$_SecKernLogs" 0 0 2 \
                "$_Disable" "kernel.dmesg_restrict = 1" \
                "$_Edit"    "/etc/systemd/coredump.conf.d/custom.conf" 2>$ANS
            case "$(cat $ANS)" in
                "$_Disable")
                    echo "kernel.dmesg_restrict = 1" >$MNT/etc/sysctl.d/50-dmesg-restrict.conf
                    dialog --backtitle "$BT" --title " $_SecKernTitle " --infobox "$_Done!" 0 0
                    sleep 2 ;;
                "$_Edit")
                    if [[ -e $MNT/etc/sysctl.d/50-dmesg-restrict.conf ]]; then
                        nano $MNT/etc/sysctl.d/50-dmesg-restrict.conf
                    else
                        msg="$_SeeConfErrBody $MNT/etc/sysctl.d/50-dmesg-restrict.conf"
                        dialog --backtitle "$BT" --title " Config Missing " --msgbox "$msg" 0 0
                    fi
            esac ;;
        *) main_menu
    esac

    security_menu
}

prep_menu() {
    if [[ $SUB_MENU != "prep_menu" ]]; then
        SUB_MENU="prep_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 8 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi

    dialog --default-item $HIGHLIGHT --backtitle "$BT" \
        --title " $_PrepMenuTitle " --menu "$_PrepMenuBody" 0 0 8 \
        "1" "$_VCKeymapTitle" \
        "2" "$_PrepKBLayout" \
        "3" "$_DevShowOpt" \
        "4" "$_PrepPartDisk" \
        "5" "$_PrepLUKS" \
        "6" "$_PrepLVM" \
        "7" "$_PrepMntPart" \
        "8" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)

    case "$(cat $ANS)" in
        "1") set_keymap       ;;
        "2") set_xkbmap       ;;
        "3") show_devices     ;;
        "4") umount_partitions ; select_device ; create_partitions ;;
        "5") luks_menu        ;;
        "6") lvm_menu         ;;
        "7") mount_partitions ;;
        *)   main_menu
    esac
    prep_menu
}

config_base_menu() {
    arch_chroot "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>>$ERR
    check_for_error

    if [[ $SUB_MENU != "config_base_menu" ]]; then
        SUB_MENU="config_base_menu" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 6 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi

    dialog --default-item $HIGHLIGHT --backtitle "$BT" --title " $_ConfBseMenuTitle " \
        --menu "$_ConfBseBody" 0 0 6 \
        "1" "$_ConfBseHost" \
        "2" "$_ConfBseSysLoc" \
        "3" "$_ConfUsrRoot" \
        "4" "$_ConfUsrNew" \
        "5" "$_SecMenuTitle" \
        "6" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)

    case "$(cat $ANS)" in
        "1") set_hostname                ;;
        "2") set_locale ; set_timezone ; set_hw_clock ;;
        "3") set_root_password           ;;
        "4") create_new_user             ;;
        "5") security_menu               ;;
        *)   main_menu
    esac

    config_base_menu
}

edit_configs() {
    FILE=""
    if [[ $SUB_MENU != "edit configs" ]]; then
        SUB_MENU="edit configs" HIGHLIGHT=1
    else
        [[ $HIGHLIGHT != 12 ]] && HIGHLIGHT=$((HIGHLIGHT + 1))
    fi

    dialog --default-item $HIGHLIGHT --backtitle "$BT" --title " $_SeeConfOptTitle " \
        --menu "$_SeeConfOptBody" 0 0 12 \
        "1" "/etc/vconsole.conf" \
        "2" "/etc/locale.conf" \
        "3" "/etc/hostname" \
        "4" "/etc/hosts" \
        "5" "/etc/sudoers" \
        "6" "/etc/mkinitcpio.conf" \
        "7" "/etc/fstab" \
        "8" "/etc/crypttab" \
        "9" "/etc/default/grub" \
        "10" "/etc/lightdm" \
        "11" "/etc/pacman.conf" \
        "12" "$_Back" 2>$ANS
    HIGHLIGHT=$(cat $ANS)

    case "$(cat $ANS)" in
        "1") [[ -e $MNT/etc/vconsole.conf   ]] && FILE="$MNT/etc/vconsole.conf"   ;;
        "2") [[ -e $MNT/etc/locale.conf     ]] && FILE="$MNT/etc/locale.conf"     ;;
        "3") [[ -e $MNT/etc/hostname        ]] && FILE="$MNT/etc/hostname"        ;;
        "4") [[ -e $MNT/etc/hosts           ]] && FILE="$MNT/etc/hosts"           ;;
        "5") [[ -e $MNT/etc/sudoers         ]] && FILE="$MNT/etc/sudoers"         ;;
        "6") [[ -e $MNT/etc/mkinitcpio.conf ]] && FILE="$MNT/etc/mkinitcpio.conf" ;;
        "7") [[ -e $MNT/etc/fstab           ]] && FILE="$MNT/etc/fstab"           ;;
        "8") [[ -e $MNT/etc/crypttab        ]] && FILE="$MNT/etc/crypttab"        ;;
        "9") [[ -e $MNT/etc/default/grub    ]] && FILE="$MNT/etc/default/grub"    ;;
        "10")
            if [[ -e $MNT/etc/lightdm/lightdm.conf ]]; then
                FILE="$MNT/etc/lightdm/lightdm.conf"
                for f in $(find $MNT/etc/lightdm | awk -F"/" '{print $NF}'); do
                    [[ $f == *greeter.conf ]] && FILE="$FILE $MNT/etc/lightdm/$f"
                done
            fi ;;
        "11") [[ -e $MNT/etc/pacman.conf ]] && FILE="$MNT/etc/pacman.conf" ;;
        *) main_menu
    esac

    if [[ $FILE != "" ]] && [[ $DISPLAY ]] && hash geany &>/dev/null; then
        geany -i $FILE
    elif [[ $FILE != "" ]]; then
        nano -p $FILE
    else
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_SeeConfErrBody" 0 0
    fi

    edit_configs
}

main_menu() {
    if [[ $MH != 5 ]]; then
        if ! [[ -e $MNT/etc ]] && [[ $MH != 1 ]]; then
            MH=1
        elif [[ -e $MNT/boot/grub ]] && [[ $MH == 2 ]]; then 
            MH=4
        else
            MH=$((MH + 1))
        fi
    fi
    dialog --default-item $MH --backtitle "$BT" --title " $_MMTitle " \
        --menu "$_MMBody" 0 0 5 \
        "1" "$_PrepMenuTitle" \
        "2" "$_InstBseMenuTitle" \
        "3" "$_ConfBseMenuTitle" \
        "4" "$_SeeConfOptTitle" \
        "5" "$_Done" 2>$ANS
    MH=$(cat $ANS)

    if [[ $(cat $ANS) -eq 2 ]]; then
        check_mount
    elif [[ $(cat $ANS) -ge 3 ]] && [[ $(cat $ANS) -le 4 ]]; then
        check_mount
        check_base
    fi

    case "$(cat $ANS)" in
        "1") prep_menu           ;;
        "2") install_base_system ;;
        "3") config_base_menu    ;;
        "4") edit_configs        ;;
        *)
            if dialog --backtitle "$BT" --yesno "$_CloseInstBody" 8 45; then
                umount_partitions
                clear && exit 0
            else
                main_menu
            fi
    esac
    main_menu
}

id_system
select_language
check_requirements
dialog --backtitle "$BT" --title " $_WelTitle $VERSION " --msgbox "$_WelBody" 0 0

while true; do
    main_menu
done
