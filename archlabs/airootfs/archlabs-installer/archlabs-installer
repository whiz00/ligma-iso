#!/usr/bin/env bash
# vim:ft=sh:fdm=marker:fmr={,}

# ArchLabs Base Installer (version 1.3 - March, 2018)
# Modified by Nathaniel Maia for use in Archlabs
# Originally Written by Carl Duff for PacBang Linux
# This program is free software, provided under the GNU GPL

ISO_USER="liveuser"               # Live user account
DIST="ArchLabs"                   # Distributor name for grub etc
VER="$DIST Installer 1.3.1"       # Installer Name / Version
ANS="/tmp/.archlabs-installer"    # Temp file to store answers
MNT_OPTS="/tmp/.mnt_opts"         # file system mount options
MNT="/mnt"                        # Installation mountpoint
ERR="/tmp/.errlog"                # error log file
EFI_MNT="/boot/efi"               # EFI partition mountpoint
LV_VG_MB=0                        # MB remaining of VG
LVM_SEP_BOOT=0                    # 1 = Seperate /boot, 2 = seperate /boot & LVM
IMG="/run/archiso/sfs/airootfs/"  # Squash image to install
KERNEL_IMG="/run/archiso/bootmnt/arch/boot/x86_64/vmlinuz"

######################################################################
##                  Utility and Check Functions                     ##
######################################################################

select_language() {
    dialog --backtitle "$BT" --title " Select Language " --menu \
        "Language / sprache / taal / språk / lingua / idioma / nyelv / língua" 0 0 9 \
        "1" $"English            (en_**)" "2" $"Español            (es_ES)" \
        "3" $"Português [Brasil] (pt_BR)" "4" $"Português          (pt_PT)" \
        "5" $"Français           (fr_FR)" "6" $"Russkiy            (ru_RU)" \
        "7" $"Italiano           (it_IT)" "8" $"Nederlands         (nl_NL)" \
        "9" $"Magyar             (hu_HU)" 2>$ANS

    case "$(cat $ANS)" in
        "1") . /archlabs-installer/english.trans    ; LOC="en_US.UTF-8" ;;
        "2") . /archlabs-installer/spanish.trans    ; LOC="es_ES.UTF-8" ;;
        "3") . /archlabs-installer/p_brasil.trans   ; LOC="pt_BR.UTF-8" ;;
        "4") . /archlabs-installer/portuguese.trans ; LOC="pt_PT.UTF-8" ;;
        "5") . /archlabs-installer/french.trans     ; LOC="fr_FR.UTF-8" ;;
        "6") . /archlabs-installer/russian.trans    ; LOC="ru_RU.UTF-8" ;;
        "7") . /archlabs-installer/italian.trans    ; LOC="it_IT.UTF-8" ;;
        "8") . /archlabs-installer/dutch.trans      ; LOC="nl_NL.UTF-8" ;;
        "9") . /archlabs-installer/hungarian.trans  ; LOC="hu_HU.UTF-8" ;;
        *) exit 0
    esac

    # Always enable en_US
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/" /etc/locale.gen

    if [[ $LOC != "en_US.UTF-8" ]]; then
        sed -i "s/#${LOC}/${LOC}/" /etc/locale.gen
    fi

    locale-gen >/dev/null 2>&1
    export LANG="$LOC"
}

check_requirements() {
    if [[ $(whoami) != "root" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --infobox "$_RtFailBody" 0 0
        sleep 3 && exit 1
    fi
    if [[ ! $(ping -c 1 google.com) ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --infobox "$_ConFailBody" 0 0
        sleep 3 && exit 1
    fi
    echo "" >$ERR
    [[ $DEBUG ]] && ( termite -e "tail -f $ERR" & ) || return 0
}

id_system() {
    if grep -q 'Apple' /sys/class/dmi/id/sys_vendor; then
        modprobe -r -q efivars || true
    else
        modprobe -q efivarfs
    fi

    if [[ -d "/sys/firmware/efi/" ]]; then
        if grep -q /sys/firmware/efi/efivars <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars
        fi
        SYSTEM="UEFI"
    else
        SYSTEM="BIOS"
    fi

    BT="$VER - $SYSTEM (x86_64)"
}

arch_chroot() {
    arch-chroot $MNT /bin/bash -c "$1"
}

check_for_error() {
    if [[ $? -eq 1 ]] && grep -wqi "error" "$ERR"; then
        msg=$(cat "$ERR")
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$msg" 0 0
        msg="An Error was encountered\n\nIt is recommended to wipe the installation and start over\n\n"
        msg="${msg}However you may select 'No' to attempt a fix yourself"
        if dialog --backtitle "$BT" --title " $_ErrTitle " --yesno "$msg" 0 0; then
            rm -rf ${MNT:?}/* ; main_menu
        else
            main_menu
        fi
    fi
}

check_mount() {
    if ! grep -q "$MNT" <<< "$(lsblk -o MOUNTPOINT)"; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
        main_menu
    fi
}

check_base() {
    if ! [[ -e $MNT/etc ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        main_menu
    fi
}

show_devices() {
    lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT \
        | grep "disk\|part\|lvm\|crypt\|NAME\|TYPE\|SIZE" >/tmp/.devlist
    dialog --backtitle "$BT" --title " $_DevShowOpt " --textbox /tmp/.devlist 0 0
}

######################################################################
##                  System Settings Functions                       ##
######################################################################

set_keymap() {
    set_xorg_keymap() {
        local msg title map maps kmaps dk k
        maps=""
        kmaps=('af' 'al' 'am' 'at' 'az' 'ba' 'bd' 'be' 'bg' 'br' 'bt' 'bw'
        'by' 'ca' 'cd' 'ch' 'cm' 'cn' 'cz' 'de' 'dk' 'ee' 'es' 'et' 'eu'
        'fi' 'fo' 'fr' 'gb' 'ge' 'gh' 'gn' 'gr' 'hr' 'hu' 'ie' 'il' 'in'
        'iq' 'ir' 'is' 'it' 'jp' 'ke' 'kg' 'kh' 'kr' 'kz' 'la' 'lk' 'lt'
        'lv' 'ma' 'md' 'me' 'mk' 'ml' 'mm' 'mn' 'mt' 'mv' 'ng' 'nl' 'no'
        'np' 'pc' 'ph' 'pk' 'pl' 'pt' 'ro' 'rs' 'ru' 'se' 'si' 'sk' 'sn'
        'sy' 'tg' 'th' 'tj' 'tm' 'tr' 'tw' 'tz' 'ua' 'us' 'uz' 'vn' 'za'
        )

        for i in "${kmaps[@]}"; do maps="$maps $i -"; done

        msg="$_XkbmapBody"
        title=" $_PrepKBLayout "
        dialog --backtitle "$BT" --title "$title" --menu "$msg" 22 60 16 $maps 2>$ANS || prep_menu
        map=$(sed 's/_.*//' $ANS)
        setxkbmap "$map" 2>>$ERR
        check_for_error

        k='Section "InputClass"\n\tIdentifier "system-keyboard"\n\tMatchIsKeyboard "on"'
        k="$k\n\tOption \"XkbLayout\" \"$map\"\nEndSection"
        dk='# KEYBOARD CONFIGURATION FILE\n\nConsult the keyboard(5) manual page.'
        dk="$dk\n\nXKBMODEL=\"\"\nXKBLAYOUT=\"$map\"\nXKBVARIANT=\"\""
        dk="$dk\nXKBOPTIONS=\"\"\nBACKSPACE=\"guess\""
        echo -e "$k" >/tmp/01-keyboard.conf
        echo -e "$dk" >/tmp/keyboard
    }

    set_console_keymap() {
        local msg title cmaps maps
        maps=""
        cmaps=$(ls -R /usr/share/kbd/keymaps | grep "map.gz")
        cmaps=$(sed 's/\.map\.gz//g' <<< "$cmaps" | sort)

        for i in $cmaps; do maps="$maps $i -"; done

        msg="$_VCKeymapBody"
        title=" $_VCKeymapTitle "
        dialog --backtitle "$BT" --title "$title" --menu "$msg" 22 60 16 $maps 2>$ANS || prep_menu
        echo "KEYMAP=$(cat $ANS)" >/tmp/vconsole.conf
    }
    set_console_keymap
    set_xorg_keymap
}

set_locale() {
    LC=$(sed 's/ UTF-8//g' <<< "$(sed 's/#//g' <<< "$(grep -v "# " /etc/locale.gen)")")
    LOCS=""
    for i in $(grep .UTF-8 <<< "$LC"); do
        LOCS="$LOCS $i -"
    done
    local title=" $_ConfBseSysLoc "
    local msg="$_localeBody"
    dialog --backtitle "$BT" --title "$title" --menu "$msg" 20 60 12 $LOCS 2>$ANS || config_menu
    LOC=$(cat $ANS)
    sed -i "s/en_US.UTF-8/${LOC}/g" $MNT/etc/locale.conf
    cp -f $MNT/etc/locale.conf $MNT/etc/default/locale
    sed -i "s/#en_US.UTF-8/en_US.UTF-8/g" $MNT/etc/locale.gen
    sed -i "s/#${LOC}/${LOC}/g" $MNT/etc/locale.gen
    sed -i "s/en_US.UTF-8/${LOC}/g" $MNT/etc/default/locale
    arch_chroot "locale-gen" >/dev/null 2>>"$ERR"
    check_for_error
    set_timezone
}

set_timezone() {
    ZONE="" SUB=""
    FULL=$(awk '{print $3}' < /usr/share/zoneinfo/zone.tab)

    if [[ $MANUAL != "True" ]]; then
        GEO=$(curl --silent freegeoip.net/xml/ | grep -i "TimeZone" | sed 's|\s*</\?TimeZone>\s*||g')
    fi

    if ([[ $GEO ]] && grep -q "$GEO" <<< "$FULL") && [[ $MANUAL != "True" ]]; then
        ZONE=$(awk -F/ '{print $1}' <<< "$GEO")
        SUB=$(awk -F/ '{print $2}' <<< "$GEO")
    else
        for i in $(grep "/" <<< "$FULL" | sed "s|/.*||g" | sort -ud); do
            ZONE="$ZONE $i -"
        done
        local title=" $_ConfBseTimeHC "
        local msg="$_TimeZBody"
        dialog --backtitle "$BT" --title "$title" --menu "$msg" 20 45 10 $ZONE 2>$ANS || config_menu
        ZONE=$(cat $ANS)

        for i in $(grep "$ZONE/" <<< "$FULL" | sed "s/${ZONE}\///g" | sort -ud); do
            SUB="$SUB $i -"
        done
        msg="$_TimeSubZBody"
        dialog --backtitle "$BT" --title "$title" --menu "$msg" 20 45 11 $SUB 2>$ANS || config_menu
        SUB=$(cat $ANS)
    fi

    if [[ $ZONE ]] && [[ $SUB ]]; then
        title=" $_ConfBseTimeHC "
        msg="$_TimeZQ $ZONE/$SUB?\n\n"
        if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
            arch_chroot "ln -sf /usr/share/zoneinfo/$ZONE/$SUB /etc/localtime" 2>>$ERR
            check_for_error
        else
            MANUAL="True"
            set_timezone
        fi
    else
        MANUAL="True"
        set_timezone
    fi

    SET_T="True"
    set_hw_clock
}

set_hw_clock() {
    arch_chroot "hwclock --systohc --utc"
    if [[ $? -eq 1 ]]; then
        arch_chroot "hwclock --systohc --utc --directisa" 2>>"$ERR"
        if [[ $? -eq 1 ]] && grep -wqi "error" "$ERR"; then
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$(cat "$ERR")" 0 0
            echo "" >$ERR
        fi
    fi
}

set_hostname() {
    HSTNM=$(awk '{print tolower($1)}' <<< "$DIST")
    dialog --backtitle "$BT" --title "$_ConfBseHost" \
        --inputbox "$_HostNameBody" 14 60 "$HSTNM" 2>$ANS || config_menu
    HOST_NAME=$(cat $ANS)
    echo "$HOST_NAME" > $MNT/etc/hostname
    echo "127.0.0.1    localhost
127.0.1.1    $HOST_NAME
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters" > $MNT/etc/hosts
}

root_password() {
    local title=" $_ConfUsrRoot "
    dialog --backtitle "$BT" --title "$title" --clear --insecure \
        --passwordbox "$_PassRtBody" 8 40 2> $ANS || config_menu
    PASSWD=$(cat $ANS)
    dialog --backtitle "$BT" --title "$title" --clear --insecure \
        --passwordbox "$_PassRtBody2" 8 40 2> $ANS || config_menu
    PASSWD2=$(cat $ANS)
    RT_PASS=""
    if [[ $PASSWD == "$PASSWD2" ]]; then
        echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd
        arch_chroot "passwd root" </tmp/.passwd >/dev/null 2>>"$ERR"
        rm /tmp/.passwd
        check_for_error
        RT_PASS="True"
    else
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
        root_password
    fi
}

create_new_user() {
    dialog --backtitle "$BT" --title " $_NUsrTitle " \
        --inputbox "$_NUsrBody" 10 40 "" 2>$ANS || config_menu
    USER=$(cat $ANS)

    while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do
        dialog --backtitle "$BT" --title " $_NUsrTitle " \
            --inputbox "$_NUsrErrBody" 10 40 "" 2>$ANS || config_menu
        USER=$(cat $ANS)
    done

    dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
        --passwordbox "$_PassNUsrBody $USER" 8 40 2>$ANS || config_menu
    PASSWD=$(cat $ANS)

    dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
        --passwordbox "$_PassNUsrBody2 $USER" 8 40 2>$ANS || config_menu
    PASSWD2=$(cat $ANS)

    while [[ $PASSWD != "$PASSWD2" ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 8 60
        dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
            --passwordbox "$_PassNUsrBody $USER" 8 40 2>$ANS || config_menu
        PASSWD=$(cat $ANS)
        dialog --backtitle "$BT" --title " $_ConfUsrNew " --clear --insecure \
            --passwordbox "$_PassNUsrBody2 $USER" 8 40 2>$ANS || config_menu
        PASSWD2=$(cat $ANS)
    done

    dialog --backtitle "$BT" --title " $_ConfUsrNew " --infobox "$_NUsrSetBody" 0 0
    sleep 2
    echo -e "$PASSWD\n$PASSWD" >/tmp/.passwd

    GROUP="rfkill,wheel,autologin,network,lp,storage,power,video,audio,lp"

    # If the first user account, change the live account
    if [[ -e $MNT/home/$ISO_USER ]]; then
        arch_chroot "passwd $ISO_USER" </tmp/.passwd >/dev/null 2>>"$ERR"
        check_for_error

        WHEEL="%wheel ALL=(ALL) ALL"
        OPENBOX="$MNT/home/$ISO_USER/.config/openbox"

        # /etc/lightdm/lightdm.conf
        L_FILES=(/etc/systemd/system/autologin@.service
        "/home/$ISO_USER/.config/openbox/autostart"
        /etc/group /etc/gshadow /etc/passwd /etc/shadow
        )

        for f in "${L_FILES[@]}"; do
            sed -i "s/${ISO_USER}/${USER}/g" ${MNT}"$f"
        done

        if grep -q "welcome.sh" $OPENBOX/autostart; then
            sed -i '/welcome.sh/d' $OPENBOX/autostart
        fi
        if grep -q 'item label="ArchLabs Welcome"' $OPENBOX/menu.xml; then
            sed -i '/item label="ArchLabs Welcome"/ i\
    <separator label="ArchLabs"/>' $OPENBOX/menu.xml
            sed -i '/item label="ArchLabs Welcome"/ { N; N; N; N; N; d; }' $OPENBOX/menu.xml
        fi

        if grep -q "archlabs-installer" $OPENBOX/rc.xml; then
            sed -i '/archlabs-installer/ { N; N; d; }' $OPENBOX/rc.xml
        fi
        if grep -q "Install Archlabs" $OPENBOX/menu.xml; then
            sed -i '/Install Archlabs/ { N; N; N; N; N; d; }' $OPENBOX/menu.xml
        fi

        sed -i 's/#$HOME/$HOME/g' $OPENBOX/autostart
        sed -i '/keypack/d' $OPENBOX/autostart
        sed -i '/al-hello/ c sleep 10; termite -e al-hello &' $OPENBOX/autostart

        rm -f $MNT/home/$ISO_USER/.config/keypack
        rm -f $MNT/home/$ISO_USER/bin/welcome.sh

        # Swap live account
        {
            arch_chroot "mv /home/$ISO_USER /home/$USER"
            arch_chroot "chown -R $USER:users /home/$USER"
            arch_chroot "usermod -aG $GROUP $USER"
            sed -i "s/# ${WHEEL}/${WHEEL}/g" $MNT/etc/sudoers
        } 2>>"$ERR"
        check_for_error
    else
        # Create new account
        {
            arch_chroot "useradd $USER -m -g users -G $GROUP -s /bin/zsh"
            arch_chroot "passwd $USER" < /tmp/.passwd >/dev/null
            arch_chroot "cp -R /etc/skel/ /home/$USER"
            arch_chroot "chown -R ${USER}:users /home/$USER"
        } 2>>"$ERR"
        check_for_error
    fi

    rm /tmp/.passwd
    if [[ -d $MNT/etc && $SET_T == "True" && $RT_PASS == "True" && $BOOTLDR_DONE == "True" ]]; then
        _InsSuccTitle="Installation Finished Successfully"
        _InsSuccBody="\nSelect Yes to close the installer and reboot the machine immediately\n\nSelect No to select modify the new system configurations"
        if dialog --backtitle "$BT" --title " $_InsSuccTitle " --yesno "$_InsSuccBody" 0 0; then
            umount_partitions ; clear ; reboot
        fi
    fi
}

######################################################################
##                System and Partitioning Functions                 ##
######################################################################

umount_partitions() {
    MOUNTED=""
    MOUNTED=$(mount | grep "$MNT" | awk '{print $3}' | sort -r)
    swapoff -a
    for i in $MOUNTED; do umount "$i" >/dev/null 2>>"$ERR" ; done
    check_for_error
}

confirm_mount() {
    local title msg
    title=" $_MntStatusTitle "
    if grep -q "$1" <<< "$(mount)"; then
        dialog --backtitle "$BT" --title "$title" --infobox "$_MntStatusSucc" 0 0
        sleep 2
        PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
        PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
        NUM_PARTS=$((NUM_PARTS - 1))
    else
        dialog --backtitle "$BT" --title "$title" --infobox "$_MntStatusFail" 0 0
        sleep 2
        prep_menu
    fi
}

select_device() {
    DEVICE=""
    local msg
    [[ $1 == "grub" ]] && msg="$_DevSelTitle for Bootloader\n\n$_DevSelBody" || msg="$_DevSelBody"
    DEVS=$(lsblk -lno NAME,SIZE,TYPE | grep 'disk' | awk '{print "/dev/" $1 " " $2}' | sort -u)
    dialog --backtitle "$BT" --title " $_DevSelTitle " --menu "$msg" 0 0 4 $DEVS 2>$ANS || prep_menu
    DEVICE=$(cat $ANS)
}

find_partitions() {
    PARTS=""
    NUM_PARTS=0
    LBLK=$(lsblk -lno NAME,SIZE,TYPE | grep "$INC_PART" | sed 's/part$/\/dev\//g')
    LBLK=$(sed 's/lvm$\|crypt$/\/dev\/mapper\//g' <<< "$LBLK")
    PARTS=$(awk '{print $3$1 " " $2}' <<< "$LBLK" | sort -u)

    for i in $PARTS; do NUM_PARTS=$((NUM_PARTS + 1)); done
    NUM_PARTS=$((NUM_PARTS / 2))

    case $INC_PART in
        'part\|lvm\|crypt')
            if [[ $SYSTEM == "UEFI" ]] && [[ $NUM_PARTS -lt 2 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_partitions
            elif [[ $SYSTEM == "BIOS" ]] && [[ $NUM_PARTS -eq 0 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
                create_partitions
            fi ;;
        'part\|crypt')
            if [[ $NUM_PARTS -eq 0 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmPartErrBody" 0 0
                create_partitions
            fi ;;
        'part\|lvm')
            if [[ $NUM_PARTS -lt 2 ]]; then
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LuksPartErrBody" 0 0
                create_partitions
            fi
    esac
}

create_partitions() {
    secure_wipe() {
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"
        if dialog --backtitle "$BT" --title " $_PartOptWipe " --yesno "$msg" 0 0; then
            clear ; echo -e "Secure wiping $DEVICE this will take a while.."
            wipe -Ifre "$DEVICE"
        else
            create_partitions
        fi
    }

    auto_partition() {
        if [[ $SYSTEM == "BIOS" ]]; then
            _AutoPartBody2="will be destroyed.\n\nAn ext4 partition will be created using all available space."
        fi
        local msg="$_AutoPartBody1 $DEVICE $_AutoPartBody2 $_AutoPartBody3"

        if dialog --backtitle "$BT" --title " $_PrepPartDisk " --yesno "$msg" 0 0; then
            parted -s "$DEVICE" print | awk '/^ / {print $1}' >/tmp/.del_parts

            for del_part in $(tac /tmp/.del_parts); do
                parted -s "$DEVICE" rm "$del_part" 2>>"$ERR"
                check_for_error
            done

            table=$(parted -s "$DEVICE" print | grep -i 'partition table' | awk '{print $3}')

            if [[ $SYSTEM == "BIOS" ]] && [[ $table != "msdos" ]]; then
                parted -s "$DEVICE" mklabel msdos 2>>"$ERR"
            elif [[ $SYSTEM == "UEFI" ]] && [[ $table != "gpt" ]]; then
                parted -s "$DEVICE" mklabel gpt 2>>"$ERR"
            fi
            check_for_error

            if [[ $SYSTEM == "BIOS" ]]; then
                parted -s "$DEVICE" mkpart primary ext4 1MiB 100% 2>>"$ERR"
            else
                parted -s "$DEVICE" mkpart ESP fat32 1MiB 513MiB 2>>"$ERR"
                parted -s "$DEVICE" set 1 boot on 2>>"$ERR"
                parted -s "$DEVICE" mkpart primary ext4 513MiB 100% 2>>"$ERR"
            fi
            check_for_error

            lsblk "$DEVICE" -o NAME,TYPE,FSTYPE,SIZE >/tmp/.devlist
            dialog --backtitle "$BT" --title "" --textbox /tmp/.devlist 0 0
        else
            create_partitions
        fi
    }

    dialog --backtitle "$BT" --title "$_PartToolTitle" --menu "$_PartToolBody" 0 0 5 \
        "$_PartOptWipe" "BIOS & UEFI" \
        "$_PartOptAuto" "BIOS & UEFI" \
        "gparted"       "BIOS & UEFI" \
        "cfdisk"        "BIOS/MBR" \
        "parted"        "UEFI/GPT" 2>$ANS
    clear
    RET=$(cat $ANS)
    if [[ $RET ]]; then
        if [[ $RET != "$_PartOptWipe" && $RET != "$_PartOptAuto" ]]; then
            $RET "$DEVICE"
        elif [[ $RET == "$_PartOptWipe" ]]; then
            secure_wipe && create_partitions
        else
            auto_partition
        fi
    fi
}

select_filesystem() {
    FS_OPTS=() CHK_NUM=0
    dialog --backtitle "$BT" --title " $_FSTitle " --menu "$_FSBody" 0 0 12 \
        "$_FSSkip" "-" \
        "btrfs"    "mkfs.btrfs -f" \
        "ext2"     "mkfs.ext2 -q" \
        "ext3"     "mkfs.ext3 -q" \
        "ext4"     "mkfs.ext4 -q" \
        "f2fs"     "mkfs.f2fs" \
        "jfs"      "mkfs.jfs -q" \
        "nilfs2"   "mkfs.nilfs2 -q" \
        "ntfs"     "mkfs.ntfs -q" \
        "reiserfs" "mkfs.reiserfs -q" \
        "vfat"     "mkfs.vfat -F32" \
        "xfs"      "mkfs.xfs -f" 2>$ANS

    case "$(cat $ANS)" in
        "$_FSSkip")
            FS="$_FSSkip"
            ;;
        "btrfs")
            FS="mkfs.btrfs -f" CHK_NUM=16
            FS_OPTS=(autodefrag "compress=zlib" "compress=lzo"
            "compress=no" "compress-force=zlib" "compress-force=lzo"
            discard noacl noatime nodatasum nospace_cache recovery
            skip_balance space_cache ssd ssd_spread
            )
            modprobe btrfs
            ;;
        "ext2")
            FS="mkfs.ext2 -q"
            ;;
        "ext3")
            FS="mkfs.ext3 -q"
            ;;
        "ext4")
            FS="mkfs.ext4 -q" CHK_NUM=6
            FS_OPTS=(dealloc discard noacl noatime nobarrier nodelalloc)
            ;;
        "f2fs")
            FS="mkfs.f2fs" CHK_NUM=16
            FS_OPTS=(data_flush disable_roll_forward disable_ext_identify
            discard fastboot flush_merge inline_xattr inline_data inline_dentry
            no_heap noacl nobarrier noextent_cache noinline_data norecovery
            )
            modprobe f2fs
            ;;
        "jfs")
            FS="mkfs.jfs -q" CHK_NUM=4
            FS_OPTS=(discard "errors=continue" "errors=panic" nointegrity)
            ;;
        "nilfs2")
            FS="mkfs.nilfs2 -q" CHK_NUM=7
            FS_OPTS=(discard nobarrier "errors=continue"
            "errors=panic" "order=relaxed" "order=strict" norecovery
            )
            ;;
        "ntfs")
            FS="mkfs.ntfs -q"
            ;;
        "reiserfs")
            FS="mkfs.reiserfs -q" CHK_NUM=5
            FS_OPTS=(acl nolog notail replayonly user_xattr)
            ;;
        "vfat")
            FS="mkfs.vfat -F32"
            ;;
        "xfs")
            FS="mkfs.xfs -f" CHK_NUM=9
            FS_OPTS=(discard filestreams ikeep largeio
            noalign nobarrier norecovery noquota wsync
            )
            ;;
        *) prep_menu
    esac

    if [[ $FS != "$_FSSkip" ]]; then
        local msg="\n$FS $PART\n\n"
        if dialog --backtitle "$BT" --title " $_FSTitle " --yesno "$msg" 0 0; then
            $FS $PART >/dev/null 2>>"$ERR"
            check_for_error
        else
            select_filesystem
        fi
    fi
}

mount_partitions() {
    mounting_options() {
        local title msg
        OPTS=""
        for i in "${FS_OPTS[@]}"; do OPTS="$OPTS $i - off"; done
        echo "" > $MNT_OPTS
        title=" $(sed "s/.*\.//g" <<< "$FS" | sed "s/-.*//g") "
        dialog --backtitle "$BT" --title "$title" --checklist "$_MntBody" 0 0 $CHK_NUM $OPTS 2>$MNT_OPTS
        sed -i 's/ /,/g' $MNT_OPTS
        sed -i '$s/,$//' $MNT_OPTS

        if [[ $(cat $MNT_OPTS) != "" ]]; then
            msg="${_MntConfBody}$(cat $MNT_OPTS)\n"
            title=" $_MntStatusTitle "
            if ! dialog --backtitle "$BT" --title "$title" --yesno "$msg" 10 75; then
                mounting_options
            fi
        fi
    }

    mount_chosen_partition() {
        mkdir -p "${MNT}$MOUNT" 2>>"$ERR"

        [[ ${#FS_OPTS[@]} -gt 0 ]] && mounting_options || sleep 0.1
        if [[ $(cat $MNT_OPTS) != "" ]]; then
            mount -o $(cat $MNT_OPTS) "$PART" "${MNT}$MOUNT" 2>>"$ERR"
        else
            mount "$PART" "${MNT}$MOUNT" 2>>"$ERR"
        fi
        check_for_error
        confirm_mount "${MNT}$MOUNT"

        BLK=$(lsblk -lno NAME,FSTYPE,TYPE)

        # Identify if mounted partition is "crypt" (LUKS on LVM, or LUKS alone)
        if grep -qi "crypt" <<< "$(lsblk -lno TYPE "$PART")"; then
            LUKS=1
            LUKS_NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")

            cryptblk=$(grep "lvm" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_DEV="$LUKS_DEV cryptdevice=$i:$LUKS_NAME"
                    LVM=1
                    break
                fi
            done

            cryptblk=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    break
                fi
            done
        elif grep -qi "lvm" <<< "$(lsblk -lno TYPE "$PART")"; then
            LVM=1
            LV_NAME=$(sed "s~^/dev/mapper/~~g" <<< "$PART")

            cryptblk=$(grep "crypt" <<< "$BLK" | grep -i "lvm2_member")
            crypts=$(awk '{print "/dev/mapper/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LV_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    LUKS_NAME=$(sed 's~/dev/mapper/~~g' <<< "$i")
                    break
                fi
            done

            cryptblk=$(grep "part" <<< "$BLK" | grep -i "crypto_luks")
            crypts=$(awk '{print "/dev/"$1}' <<< "$cryptblk" | uniq)
            for i in ${crypts}; do
                if grep -q "$LUKS_NAME" <<< "$(lsblk -lno NAME "$i")"; then
                    UUID=$(lsblk -lno UUID,TYPE,FSTYPE "$i" | grep "part")
                    LUKS_UUID=$(grep -i "crypto_luks" <<< "$UUID" | awk '{print $1}')
                    LUKS_DEV="$LUKS_DEV cryptdevice=UUID=$LUKS_UUID:$LUKS_NAME"
                    LUKS=1
                    break
                fi
            done
        fi
    }

    make_swap() {
        dialog --backtitle "$BT" --title " $_PrepMntPart " --menu "$_SelSwpBody" 0 0 7 \
            "$_SelSwpNone" $"-" \
            "$_SelSwpFile" $"-" \
            $PARTS 2>$ANS || prep_menu

        if [[ $(cat $ANS) != "$_SelSwpNone" ]]; then
            PART=$(cat $ANS)

            if [[ $PART == "$_SelSwpFile" ]]; then
                local title msg
                title=" $_SelSwpFile "
                msg="\nM = MB, G = GB\n"
                mem=$(grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//')
                dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 9 30 "${mem}M" 2>$ANS || make_swap
                tot=$(cat $ANS)

                while [[ $(echo ${tot: -1} | grep "M\|G") == "" ]]; do
                    msg="\n$_SelSwpFile $_ErrTitle: M = MB, G = GB\n\n"
                    dialog --backtitle "$BT" --title "$title" --msgbox "$msg" 0 0
                    msg="\nM = MB, G = GB\n"
                    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 9 30 "${mem}M" 2>$ANS || make_swap
                    tot=$(cat $ANS)
                done

                fallocate -l "$tot" $MNT/swapfile 2>>"$ERR"
                chmod 600 $MNT/swapfile 2>>"$ERR"
                mkswap $MNT/swapfile >/dev/null 2>>"$ERR"
                swapon $MNT/swapfile >/dev/null 2>>"$ERR"
                check_for_error
            else
                if [[ $(lsblk -o FSTYPE "$PART" | grep -i "swap") != "swap" ]]; then
                    title=" $_PrepMntPart " msg="\nmkswap $PART\n\n"
                    if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
                        mkswap "$PART" >/dev/null 2>>"$ERR"
                    else
                        mount_partitions
                    fi
                fi
                swapon "$PART" >/dev/null 2>>"$ERR"
                check_for_error
                PARTS=$(sed "s~${PART} [0-9]*[G-M]~~" <<< "$PARTS")
                PARTS=$(sed "s~${PART} [0-9]*\.[0-9]*[G-M]~~" <<< "$PARTS" | sed s~${PART}$' -'~~)
                NUM_PARTS=$((NUM_PARTS - 1))
            fi
        fi
    }

    MOUNT=""
    local title msg

    title=" $_PrepMntPart "
    msg="$_WarnMount1 '$_FSSkip' $_WarnMount2"
    dialog --backtitle "$BT" --title "$title" --msgbox "$msg" 0 0

    lvm_detect
    INC_PART='part\|lvm\|crypt'
    umount_partitions
    find_partitions

    msg="$_SelRootBody"
    dialog --backtitle "$BT" --title "$title" --menu "$msg" 0 0 7 $PARTS 2>$ANS || prep_menu
    PART=$(cat $ANS)
    ROOT_PART=$(cat $ANS)

    select_filesystem
    mount_chosen_partition
    make_swap

    # Extra Step for VFAT EFI Partition.. Not in an LVM container.
    if [[ $SYSTEM == "UEFI" ]]; then
        msg="$_SelUefiBody"
        dialog --backtitle "$BT" --title "$title" --menu "$msg" 0 0 7 $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        EFI_PART=$(cat $ANS)
        if grep -q 'fat' <<< "$(fsck -N "$PART")"; then
            msg="$_FormUefiBody $PART $_FormUefiBody2"
            if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
                mkfs.vfat -F32 "$PART" >/dev/null 2>>"$ERR"
            fi
        else
            mkfs.vfat -F32 "$PART" >/dev/null 2>>"$ERR"
        fi
        check_for_error
        mkdir -p ${MNT}$EFI_MNT 2>>"$ERR"
        mount "$PART" ${MNT}$EFI_MNT 2>>"$ERR"
        check_for_error
        confirm_mount ${MNT}$EFI_MNT
    fi

    # leftover partitions
    while [[ $NUM_PARTS -gt 0 ]]; do
        msg="$_ExtPartBody"
        title=" $_PrepMntPart "
        dialog --backtitle "$BT" --title "$title" --menu "$msg" 0 0 7 "$_Done" $"-" $PARTS 2>$ANS || prep_menu
        PART=$(cat $ANS)
        if [[ $PART == "$_Done" ]]; then
            break ; main_menu
        else
            MOUNT=""
            select_filesystem
            [[ $SYSTEM == "UEFI" ]] && MNT_EXAMPLES="/home /var" || MNT_EXAMPLES="/boot /home /var"

            title=" $_PrepMntPart $PARTITON "
            msg="$_ExtPartBody1$MNT_EXAMPLES\n"
            dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "/" 2>$ANS || prep_menu
            MOUNT=$(cat $ANS)

            while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
                msg="${_ExtPartBody1}$MNT_EXAMPLES\n"
                dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
                dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "/" 2>$ANS || prep_menu
                MOUNT=$(cat $ANS)
            done
            mount_chosen_partition
            if [[ $MOUNT == "/usr" ]]; then
                ( ! grep -q "usr shutdown" <<< "$HOOKS" ) && HOOKS="$HOOKS usr shutdown" || HOOKS="usr shutdown"
            fi

            if [[ $MOUNT == "/boot" ]]; then
                ( grep -q "lvm" <<< "$(lsblk -lno TYPE "$PART")" ) && LVM_SEP_BOOT=2 || LVM_SEP_BOOT=1
            fi
        fi
    done
}

######################################################################
##               Encryption (dm_crypt) Functions                    ##
######################################################################

luks_password() {
    dialog --backtitle "$BT" --title " $_PrepLUKS " --clear --insecure \
        --passwordbox "$_LuksPassBody" 10 40 2> $ANS || prep_menu
    PASSWD=$(cat $ANS)
    dialog --backtitle "$BT" --title " $_PrepLUKS " --clear --insecure \
        --passwordbox "$_PassNUsrBody2 $LUKS_ROOT_NAME" 8 40 2> $ANS || prep_menu
    PASSWD2=$(cat $ANS)
    if [[ $PASSWD != "$PASSWD2" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_PassErrBody" 10 40
        luks_password
    else
        LUKS_PASSWD="$PASSWD"
    fi
}

luks_open() {
    local title msg default
    LUKS_ROOT_NAME=""
    INC_PART='part\|crypt\|lvm'
    umount_partitions
    find_partitions
    title=" $_LuksOpen "
    msg="$_LuksMenuBody"
    default="cryptroot"
    dialog --backtitle "$BT" --title "$title" --menu "$msg" 10 50 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)
    msg="$_LuksOpenBody"
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 10 50 "$default" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
    msg="${_LuksWaitBody} ${LUKS_ROOT_NAME}$_LuksWaitBody2 ${PART}\n\n"
    dialog --backtitle "$BT" --title " $_LuksOpen " --infobox "$msg" 10 50
    echo "$PASSWD" | cryptsetup open --type luks "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
    luks_show
}

luks_setup() {
    local default msg title
    modprobe -a dm-mod dm_crypt
    INC_PART='part\|lvm'
    umount_partitions
    find_partitions
    title=" $_LuksEncrypt "
    msg="$_LuksEncryptBody"
    dialog --backtitle "$BT" --title "$title" --menu "$msg" 12 50 7 $PARTS 2>$ANS || luks_menu
    PART=$(cat $ANS)
    msg="$_LuksOpenBody"
    default="cryptroot"
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 12 50 "$default" 2>$ANS || luks_menu
    LUKS_ROOT_NAME=$(cat $ANS)
    luks_password
}

luks_default() {
    luks_setup
    local msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
    dialog --backtitle "$BT" --title " $_LuksEncrypt " --infobox "$msg" 0 0
    echo "$PASSWD" | cryptsetup -q luksFormat "$PART" 2>$ERR
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>$ERR
    check_for_error
    luks_show
}

luks_key() {
    local msg title default
    luks_setup
    msg="$_LuksCipherKey"
    title=" $_PrepLUKS "
    def="-s 512 -c aes-xts-plain64"
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "$default" 2>$ANS || luks_menu
    msg="$_LuksWaitBody ${LUKS_ROOT_NAME}$_LuksWaitBody2 $PART\n\n"
    dialog --backtitle "$BT" --title " $_LuksEncryptAdv " --infobox "$msg" 0 0
    echo "$PASSWD" | cryptsetup -q "$(cat $ANS)" luksFormat "$PART" 2>"$ERR"
    check_for_error
    echo "$PASSWD" | cryptsetup open "$PART" "$LUKS_ROOT_NAME" 2>"$ERR"
    check_for_error
    luks_show
}

luks_show(){
    echo -e "$_LuksEncryptSucc" >/tmp/.devlist
    lsblk -o NAME,TYPE,FSTYPE,SIZE "$PART" | grep "part\|crypt\|NAME\|TYPE\|FSTYPE\|SIZE" >>/tmp/.devlist
    dialog --backtitle "$BT" --title " $_LuksEncrypt " --textbox /tmp/.devlist 0 0
    luks_menu
}

luks_menu() {
    local msg="${_LuksMenuBody}${_LuksMenuBody2}${_LuksMenuBody3}"
    dialog --backtitle "$BT" --title " $_PrepLUKS " --menu "$msg" 0 0 4 \
        "$_LuksOpen"       "cryptsetup open --type luks" \
        "$_LuksEncrypt"    "cryptsetup -q luksFormat" \
        "$_LuksEncryptAdv" "cryptsetup -q -s -c luksFormat" \
        "$_Back" "-" 2>$ANS

    case "$(cat $ANS)" in
        "$_LuksOpen")       luks_open    ;;
        "$_LuksEncrypt")    luks_default ;;
        "$_LuksEncryptAdv") luks_key     ;;
        *) prep_menu
    esac
    luks_menu
}

######################################################################
##               Logical Volume Management Functions                ##
######################################################################

lvm_detect() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)

    if [[ $LV != "" ]] && [[ $LV_VG != "" ]] && [[ $LVM_PV != "" ]]; then
        dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "$_LvmDetBody" 0 0
        modprobe dm-mod 2>>"$ERR"
        check_for_error
        vgscan >/dev/null 2>&1
        vgchange -ay >/dev/null 2>&1
    fi
}

lvm_show_vg() {
    local msg title
    VG_LIST=""
    list=$(lvs --noheadings | awk '{print $2}' | uniq)

    for i in $list; do
        size=$(vgdisplay "$i" | grep -i "vg size" | awk '{print $3$4}')
        VG_LIST="$VG_LIST $i $size"
    done

    if [[ $VG_LIST == "" ]]; then
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmVGErr" 0 0
        lvm_menu
    fi

    title=" $_PrepLVM "
    msg="$_LvmSelVGBody"
    dialog --backtitle "$BT" --title "$title" --menu "$msg" 0 0 5 $VG_LIST 2>$ANS || lvm_menu
}

lvm_create() {
    check_lv_size() {
        LV_SIZE_INVALID=0

        local chars=0
        local n=${#LV_SIZE}
        local ln=${LV_SIZE:0:1}
        local lv=$((${#LV_SIZE} - 1))

        if [[ $n -eq 0 ]] || [[ $ln -eq "0" ]]; then
            LV_SIZE_INVALID=1
        fi

        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            while [[ $chars -lt $lv ]]; do
                if [[ ${LV_SIZE:chars:1} != [0-9] ]]; then
                    LV_SIZE_INVALID=1
                    break
                fi
                chars=$((chars + 1))
            done
        fi

        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            LV_SIZE_TYPE=${LV_SIZE:$lv:1}
            case $LV_SIZE_TYPE in
                "m"|"M"|"g"|"G") LV_SIZE_INVALID=0 ;;
                *)               LV_SIZE_INVALID=1
            esac
        fi

        if [[ $LV_SIZE_INVALID -eq 0 ]]; then
            case $LV_SIZE_TYPE in
                "G"|"g")
                    if [[ $((${LV_SIZE:0:$lv} * 1000)) -ge $LV_VG_MB ]]; then
                        LV_SIZE_INVALID=1
                    else
                        LV_VG_MB=$((LV_VG_MB - $((${LV_SIZE:0:$lv} * 1000))))
                    fi ;;
                "M"|"m")
                    if [[ ${LV_SIZE:0:$LESS1} -ge $LV_VG_MB ]]; then
                        LV_SIZE_INVALID=1
                    else
                        LV_VG_MB=$((LV_VG_MB - ${LV_SIZE:0:$lv}))
                    fi ;;
                *) LV_SIZE_INVALID=1
            esac
        fi
    }

    LV_VG="" VG_PARTS=""
    LV_VG_MB=0
    INC_PART='part\|crypt'

    umount_partitions
    find_partitions
    PARTS=$(sed 's/M\|G\|T/& off/g' <<< "$PARTS")

    local msg="$_LvmNameVgBody"
    local title=" $_LvmCreateVG "
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
    LV_VG=$(cat $ANS)

    n=${#LV_VG}
    ln=${LV_VG:0:1}
    has=$(grep -q "$LV_VG" <<< "$(lsblk)")
    while [[ $ln == "/" ]] || [[ $n -eq 0 ]] || [[ $LV_VG =~ \ |\' ]] || [[ $has ]]; do
        dialog --backtitle "$BT" --title "$_ErrTitle" --msgbox "$_LvmNameVgErr" 0 0
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
        LV_VG=$(cat $ANS)
    done

    msg="$_LvmPvSelBody $_UseSpaceBar"
    dialog --backtitle "$BT" --title "$title" --checklist "$msg" 0 0 7 $PARTS 2>$ANS || prep_menu
    if [[ $(cat $ANS) != "" ]]; then
        VG_PARTS=$(cat $ANS)
    else
        prep_menu
    fi

    msg="${_LvmPvConfBody1}: ${LV_VG}\n\n$_LvmPvConfBody2${VG_PARTS}"
    if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
        msg="$_LvmPvActBody1${LV_VG}.$_PlsWaitBody"
        dialog --backtitle "$BT" --title "$title" --infobox "$msg" 10 50
        sleep 1
        vgcreate -f "$LV_VG" "$VG_PARTS" >/dev/null 2>>"$ERR"
        check_for_error

        VG_SIZE=$(vgdisplay "$LV_VG" | grep 'VG Size' | sed 's/\..*//' | sed 's/[^0-9]*//g')
        VG_SIZE_TYPE=$(vgdisplay "$LV_VG" | grep 'VG Size' | awk '{print $4}')
        if [[ ${VG_SIZE_TYPE:0:1} == "G" ]]; then
            LV_VG_MB=$((VG_SIZE * 1000))
        else
            LV_VG_MB=$VG_SIZE
        fi

        msg="${_LvmPvDoneBody1}'$LV_VG' $_LvmPvDoneBody2\n\n($VG_SIZE $VG_SIZE_TYPE)"
        dialog --backtitle "$BT" --title "$title" --msgbox "$msg" 8 50
    else
        lvm_menu
    fi

    msg="$_LvmLvNumBody1 $LV_VG. $_LvmLvNumBody2"
    dialog --backtitle "$BT" --title "$title" --radiolist "$msg" 0 0 9 \
        "1" "-" off \
        "2" "-" off \
        "3" "-" off \
        "4" "-" off \
        "5" "-" off \
        "6" "-" off \
        "7" "-" off \
        "8" "-" off \
        "9" "-" off 2>$ANS
    if [[ $(cat $ANS) == "" ]]; then
        lvm_menu
    else
        NUM_LVS=$(cat $ANS)
    fi

    while [[ $NUM_LVS -gt 1 ]]; do
        title=" $_LvmCreateVG (LV:$NUM_LVS) "
        msg="$_LvmLvNameBody1"
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
        LV_NAME=$(cat $ANS)

        ln=${LV_NAME:0:1}
        n=${#LV_NAME}
        has=$(grep -q "$LV_NAME" <<< "$(lsblk)")
        while [[ $ln == "/" ]] || [[ $n -eq 0 ]] || [[ $LV_NAME =~ \ |\' ]] || [[ $has ]]; do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
            dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
            LV_NAME=$(cat $ANS)
        done

        msg="${LV_VG}: ${VG_SIZE}$VG_SIZE_TYPE (${LV_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2"
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
        LV_SIZE=$(cat $ANS)
        check_lv_size

        while [[ $LV_SIZE_INVALID -eq 1 ]]; do
            dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvSizeErrBody" 0 0
            dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "" 2>$ANS || prep_menu
            LV_SIZE=$(cat $ANS)
            check_lv_size
        done

        lvcreate -L "$LV_SIZE" "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
        check_for_error

        msg="$_Done LV $LV_NAME ($LV_SIZE) $_LvmPvDoneBody2."
        dialog --backtitle "$BT" --title "$title" --msgbox "$msg" 0 0
        NUM_LVS=$((NUM_LVS - 1))
    done

    title=" $_LvmCreateVG (LV:$NUM_LVS) "
    msg="$_LvmLvNameBody1 $_LvmLvNameBody2 (${LV_VG_MB}MB)."
    dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
    LV_NAME=$(cat $ANS)

    ln=${LV_NAME:0:1}
    n=${#LV_NAME}
    has=$(grep -q "$LV_NAME" <<< "$(lsblk)")
    while [[ $ln == "/" ]] || [[ $n -eq 0 ]] || [[ $LV_NAME =~ \ |\' ]] || [[ $has ]]; do
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$_LvmLvNameErrBody" 0 0
        dialog --backtitle "$BT" --title "$title" --inputbox "$msg" 0 0 "lvol" 2>$ANS || prep_menu
        LV_NAME=$(cat $ANS)
    done

    lvcreate -l +100%FREE "$LV_VG" -n "$LV_NAME" 2>>"$ERR"
    check_for_error
    NUM_LVS=$((NUM_LVS - 1))
    LVM=1

    title=" $_LvmCreateVG "
    msg="$_LvmCompBody"
    if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
        show_devices
    else
        lvm_menu
    fi
}

lvm_del_vg() {
    lvm_show_vg
    if dialog --backtitle "$BT" --title " $_LvmDelVG " --yesno "$_LvmDelQ" 0 0; then
        vgremove -f "$(cat $ANS)" >/dev/null 2>&1
    fi
    lvm_menu
}

lvm_del_all() {
    LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
    LV_VG=$(vgs -o vg_name --noheading 2>/dev/null)
    LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)

    if dialog --backtitle "$BT" --title " $_LvMDelAll " --yesno "$_LvmDelQ" 0 0; then
        for i in $LV; do lvremove -f "/dev/mapper/$i" >/dev/null 2>&1; done
        for i in $LV_VG; do vgremove -f "$i" >/dev/null 2>&1; done
        for i in $LVM_PV; do pvremove -f "$i" >/dev/null 2>&1; done
        LVM=0
    fi
    lvm_menu
}

lvm_menu() {
    dialog --backtitle "$BT" --title " $_PrepLVM " --infobox "$_PlsWaitBody" 0 0
    sleep 1
    lvm_detect

    dialog --backtitle "$BT" --title " $_PrepLVM " --menu "$_LvmMenu" 0 0 4 \
        "$_LvmCreateVG" "vgcreate -f, lvcreate -L -n" \
        "$_LvmDelVG"    "vgremove -f" \
        "$_LvMDelAll"   "lvrmeove, vgremove, pvremove -f" \
        "$_Back" "-" 2>$ANS

    case "$(cat $ANS)" in
        "$_LvmCreateVG") lvm_create  ;;
        "$_LvmDelVG")    lvm_del_vg  ;;
        "$_LvMDelAll")   lvm_del_all ;;
        *)               prep_menu
    esac
}

######################################################################
##                      Installation Functions                      ##
######################################################################

install_root() {
    clear
    if [[ -e $IMG ]]; then
        rsync -a --progress $IMG $MNT/ 2>>"$ERR"
        check_for_error
    else
        echo -e "IMG has not been properly configured... Exiting" ; exit 1
    fi

    local rfiles=(archlabs-installer etc/sudoers.d/g_wheel
    etc/mkinitcpio-archiso.conf usr/bin/install-al
    etc/polkit-1/rules.d/49-nopasswd_global.rules
    )
    for f in "${rfiles[@]}"; do rm -rf $MNT/$f ; done

    find $MNT/usr/lib/initcpio -name archiso* -type f -exec rm '{}' \;

    local autostart="$MNT/etc/skel/.config/openbox/autostart"
    sed -i '/al-hello/ c sleep 10; termite --exec=/usr/bin/al-hello &' $autostart
    sed -i 's|#$HOME/.config/setup &|$HOME/.config/setup &|g' $autostart
    sed -i 's/volatile/auto/g' $MNT/etc/systemd/journald.conf

    cp -f $KERNEL_IMG $MNT/boot/vmlinuz-linux 2>>$ERR
    check_for_error

    [[ -e /tmp/keyboard ]] && cp -f /tmp/keyboard $MNT/etc/default/keyboard
    [[ -e /tmp/01-keyboard.conf ]] && cp -f /tmp/01-keyboard.conf $MNT/etc/X11/xorg.conf.d/01-keyboard.conf
    [[ -e /tmp/vconsole.conf ]] && cp -f /tmp/vconsole.conf $MNT/etc/vconsole.conf

    reflector --score 40 --fastest 10 --sort rate --save $MNT/etc/pacman.d/mirrorlist --verbose

    arch_chroot "mkdir -p /var/lib/pacman/sync"
    arch_chroot "touch /var/lib/pacman/sync/{core.db,extra.db,community.db}"
    arch_chroot "dirmngr </dev/null"
    arch_chroot "gpg --receive-keys C1A60EACE707FDA5"
    arch_chroot "pacman-key --init && pacman-key --populate archlinux"
    arch_chroot "pacman-key --populate archlabs"
    arch_chroot "pacman -Syyu --noconfirm"
    arch_chroot "systemctl enable ntpd.service -f"
    arch_chroot "systemctl enable NetworkManager.service -f"
    arch_chroot "pacman -S iputils --noconfirm"
    arch_chroot "pacman -S base-devel git --needed --noconfirm"
}

install_bootloader() {
    grub_configuration() {
        local CFG="$MNT/etc/default/grub"
        sed -i "s/GRUB_DISTRIBUTOR=.*/GRUB_DISTRIBUTOR=\"${DIST}\"/g" $CFG
        if [[ $LUKS -eq 1 ]]; then
            if [[ $LUKS_DEV ]]; then
                sed -i "s~GRUB_CMDLINE_LINUX=\"\"~GRUB_CMDLINE_LINUX=\"${LUKS_DEV}\"~g" $CFG
            fi
            sed -i "s/#GRUB_ENABLE_CRYPTODISK=y/GRUB_ENABLE_CRYPTODISK=y/g" $CFG
        fi
        if [[ $SYSTEM == "BIOS" ]]; then
            if ([[ $LVM -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]]) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
                sed -i "s/GRUB_PRELOAD_MODULES=.*/GRUB_PRELOAD_MODULES=\"lvm\"/g" $CFG
            fi
        fi
    }

    bios_bootloader() {
        select_device "grub"
        grub_configuration
        arch_chroot "grub-install --target=i386-pc --recheck --force $DEVICE" 2>>$ERR
        check_for_error
    }

    uefi_bootloader() {
        local ldr cmd part num
        if grep -q "/sys/firmware/efi/efivars" <<< "$(mount)"; then
            mount -t efivarfs efivarfs /sys/firmware/efi/efivars &>/dev/null
            arch_chroot "mount -t efivarfs efivarfs /sys/firmware/efi/efivars" &>/dev/null
        fi
        grub_configuration
        cmd="grub-install --target=x86_64-efi --efi-directory=$EFI_MNT --bootloader-id=$DIST --force"
        arch_chroot "$cmd" 2>>$ERR

        local efi_dirs
        efi_dirs=($(find ${MNT}$EFI_MNT/EFI -maxdepth 1 -type d))
        for i in "${efi_dirs[@]}"; do
            name=$(basename "$i")
            if grep -qi "boot" <<< "$name"; then
                BDIR=/EFI/$name
                break
            else
                BDIR=/EFI/boot
            fi
        done
        mkdir -p $MNT/$EFI_MNT/$BDIR
        arch_chroot "cp -rf $EFI_MNT/EFI/$DIST/grubx64.efi $EFI_MNT/$BDIR/bootx64.efi"

        part=$(sed 's|/dev/||g' <<< "$EFI_PART" | sed 's|[0-9]*||g')
        num=$(grep -o '[1-9]' <<< "$EFI_PART")
        ldr="$BDIR/bootx64.efi"
        cmd="efibootmgr --create --disk $part --part $num --loader $ldr --label '$DIST Linux'"
        arch_chroot "$cmd" 2>>$ERR
        check_for_error
    }

    check_mount
    arch_chroot "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/bin/core_perl"
    if [[ $BOOTLDR_DONE != "True" ]]; then
        echo "installing bootloader" >>$ERR
        [[ $SYSTEM == "BIOS" ]] && bios_bootloader || uefi_bootloader
        BOOTLDR_DONE="True"
    fi
    os-prober &>/dev/null
    arch_chroot "os-prober" &>/dev/null
    arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>$ERR
    check_for_error

    if [[ $SYSTEM != "UEFI" ]]; then
        msg="Bootloader installation completed successfully"
        dialog --backtitle "$BT" --title " $_InstBootldr " --msgbox "$msg" 0 50
    fi
}

install_system() {
    if [[ ! -e $MNT/etc ]]; then
        local title
        local msg

        title="Begin System Unpacking"
        msg="This will unpack $DIST to the partition chosen during mounting:\n$ROOT_PART"
        if [[ $SYSTEM == "UEFI" ]]; then
            msg="$msg\n\nThe bootloader will be written to the system EFI partition:\n$EFI_PART"
        else
            msg="$msg\n\nBIOS (legacy boot) systems like this can install the bootloader on any of the available partitions.
            \nDuring the unpack you will be asked which partition to install it on.
            \nThe recommended and simple approach is to choose the root (/) partition:\n$ROOT_PART"
        fi
        msg="$msg\n\nDo you want to continue?"

        if dialog --backtitle "$BT" --title "$title" --yesno "$msg" 0 0; then
            echo "Unpacking base system" >>$ERR
            install_root
        fi
    fi

    echo "generating FSTAB" >>$ERR
    genfstab -U -p $MNT > $MNT/etc/fstab 2>>$ERR
    if [[ -f $MNT/swapfile ]]; then
        sed -i "s/\\${MNT}//" $MNT/etc/fstab 2>>$ERR
    fi
    check_for_error

    [[ -e $KERNEL_IMG ]] && mkdir -p $MNT/boot && cp -f $KERNEL_IMG $MNT/boot/vmlinuz-linux

    run_mkinitcpio
    install_bootloader
    config_menu
}

run_mkinitcpio() {
    echo "running mkinitcpio for linux kernel" >>$ERR
    local conf="$MNT/etc/mkinitcpio.conf"

    if [[ $LVM -eq 1 && $LUKS -eq 0 ]]; then
        sed -i 's/block filesystems/block lvm2 filesystems/g' $conf 2>>$ERR
    elif [[ $LVM -eq 1 && $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt lvm2 filesystems/g' $conf 2>>$ERR
    elif [[ $LVM -eq 0 && $LUKS -eq 1 ]]; then
        sed -i 's/block filesystems/block encrypt filesystems/g' $conf 2>>$ERR
    fi

    if [[ $LUKS_DEV && $LUKS_PASSWD && $LUKS_UUID ]]; then
        local dev
        dev=$(lsblk -lno NAME,UUID,TYPE | grep "part")
        dev="/dev/$(grep "$LUKS_UUID" <<< "$dev" | awk '{print $1}')"
        arch_chroot "dd bs=512 count=8 if=/dev/urandom of=/crypto_keyfile.bin" 2>>$ERR
        arch_chroot "chmod 000 /crypto_keyfile.bin" 2>>$ERR
        echo "INFO: Setting up single password decryption at boot"
        echo "INFO: Creating encryption keyfile: /crypto_keyfile.bin"
        arch_chroot "echo '$LUKS_PASSWD' | cryptsetup luksAddKey $dev /crypto_keyfile.bin" 2>>$ERR
        sed -i 's/FILES=()/FILES=(\/crypto_keyfile.bin)/g' $conf 2>>$ERR
    fi

    if [[ $HOOKS ]]; then
        sed -i "s/keyboard fsck/keyboard ${HOOKS} fsck/g" $conf 2>>$ERR
    fi

    arch_chroot "mkinitcpio -p linux" 2>>$ERR
    check_for_error
}

######################################################################
##                          Menu Interfaces                         ##
######################################################################

prep_menu() {
    if [[ $MENU != "prep_menu" ]]; then
        MENU="prep_menu" HL=1
    elif [[ $HL != 7 ]]; then
        HL=$((HL + 1))
    fi

    dialog --default-item $HL --backtitle "$BT" \
        --title " $_PrepMenuTitle " --menu "$_PrepMenuBody" 17 60 7 \
        "1" "$_PrepKBLayout" \
        "2" "$_DevShowOpt" \
        "3" "$_PrepPartDisk" \
        "4" "$_PrepLUKS" \
        "5" "$_PrepLVM" \
        "6" "$_PrepMntPart" \
        "7" "$_Back" 2>$ANS
    HL=$(cat $ANS)

    case "$(cat $ANS)" in
        "1") set_keymap       ;;
        "2") show_devices     ;;
        "3") umount_partitions ; select_device ; create_partitions ;;
        "4") luks_menu        ;;
        "5") lvm_menu         ;;
        "6") mount_partitions ;;
        *)   main_menu
    esac
    prep_menu
}

config_menu() {
    arch_chroot "export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl"
    if [[ $MENU != "config_menu" ]]; then
        MENU="config_menu" HL=1
    elif [[ $HL != 5 ]]; then
        HL=$((HL + 1))
    fi

    local title=" $_ConfBseMenuTitle "
    dialog --default-item $HL --backtitle "$BT" --title "$title" \
        --menu "$_ConfBseBody" 14 60 5 \
        "1" "$_ConfBseHost" \
        "2" "$_ConfBseSysLoc" \
        "3" "$_ConfUsrRoot" \
        "4" "$_ConfUsrNew" \
        "5" "$_Back" 2>$ANS
    HL=$(cat $ANS)

    case "$(cat $ANS)" in
        "1") set_hostname    ;;
        "2") set_locale      ;;
        "3") root_password   ;;
        "4") create_new_user ;;
        *)   main_menu
    esac
    config_menu
}

edit_configs() {
    if [[ $MENU != "edit configs" ]]; then
        MENU="edit configs" HL=1
    elif [[ $HL != 11 ]]; then
        HL=$((HL + 1))
    fi

    local title=" $_SeeConfOptTitle "
    dialog --default-item $HL --backtitle "$BT" --title "$title" \
        --menu "$_SeeConfOptBody" 21 60 11 \
        "1" "keymap configs" \
        "2" "locale configs" \
        "3" "/etc/hostname" \
        "4" "/etc/hosts" \
        "5" "/etc/sudoers" \
        "6" "/etc/mkinitcpio.conf" \
        "7" "/etc/fstab" \
        "8" "/etc/crypttab" \
        "9" "/etc/default/grub" \
        "10" "/etc/pacman.conf" \
        "11" "$_Back" 2>$ANS
    HL=$(cat $ANS)

    FILE=""
    case "$(cat $ANS)" in
        "1")
            [[ -e $MNT/etc/vconsole.conf ]] && FILE="$MNT/etc/vconsole.conf"
            [[ -e $MNT/etc/default/keyboard ]] && FILE="$FILE $MNT/etc/default/keyboard"
            [[ -e $MNT/etc/X11/xorg.conf.d/01-keyboard.conf ]] \
                && FILE="$FILE $MNT/etc/X11/xorg.conf.d/01-keyboard.conf" ;;
        "2")
             [[ -e $MNT/etc/locale.conf ]] && FILE="$MNT/etc/locale.conf"
             [[ -e $MNT/etc/default/locale ]] && FILE="$FILE $MNT/etc/default/locale" ;;
        "3") [[ -e $MNT/etc/hostname ]] && FILE="$MNT/etc/hostname" ;;
        "4") [[ -e $MNT/etc/hosts ]] && FILE="$MNT/etc/hosts" ;;
        "5") [[ -e $MNT/etc/sudoers ]] && FILE="$MNT/etc/sudoers" ;;
        "6") [[ -e $MNT/etc/mkinitcpio.conf ]] && FILE="$MNT/etc/mkinitcpio.conf" ;;
        "7") [[ -e $MNT/etc/fstab ]] && FILE="$MNT/etc/fstab" ;;
        "8") [[ -e $MNT/etc/crypttab ]] && FILE="$MNT/etc/crypttab" ;;
        "9") [[ -e $MNT/etc/default/grub ]] && FILE="$MNT/etc/default/grub" ;;
        "10") [[ -e $MNT/etc/pacman.conf ]] && FILE="$MNT/etc/pacman.conf" ;;
        *) main_menu
    esac

    if [[ $FILE && $DISPLAY ]] && hash geany &>/dev/null; then
        geany -i $FILE
    elif [[ $FILE ]]; then
        vim -O $FILE
    else
        local msg="$_SeeConfErrBody"
        dialog --backtitle "$BT" --title " $_ErrTitle " --msgbox "$msg" 0 0
    fi

    edit_configs
}

main_menu() {
    if [[ $MH != 5 ]]; then
        if ! [[ -e $MNT/etc ]] && [[ $MH != 1 ]]; then
            MH=1
        elif [[ -e $MNT/boot/grub ]] && [[ $MH == 2 ]]; then
            MH=4
        else
            MH=$((MH + 1))
        fi
    fi
    dialog --default-item $MH --backtitle "$BT" --title " $_MMTitle " \
        --menu "$_MMBody" 20 60 5 \
        "1" "$_PrepMenuTitle" \
        "2" "$_InstBseMenuTitle" \
        "3" "$_ConfBseMenuTitle" \
        "4" "$_SeeConfOptTitle" \
        "5" "$_Done" 2>$ANS
    MH=$(cat $ANS)

    if [[ $(cat $ANS) -eq 2 ]]; then
        check_mount
    elif [[ $(cat $ANS) -ge 3 ]] && [[ $(cat $ANS) -le 4 ]]; then
        check_mount
        check_base
    fi

    case "$(cat $ANS)" in
        "1") prep_menu      ;;
        "2") install_system ;;
        "3") config_menu    ;;
        "4") edit_configs   ;;
        *)
            if dialog --backtitle "$BT" --yesno " $_CloseInstBody " 8 45; then
                umount_partitions ; clear ; exit 0
            fi
    esac
    main_menu
}

[[ $1 == "--debug" || $1 == "-d" ]] && DEBUG="True" || DEBUG=""

select_language
check_requirements
id_system
dialog --backtitle "$BT" --title " $_WelTitle $VER " --msgbox "$_WelBody" 0 0

MH=0 HL=0
while true; do main_menu; done
